<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>框架学习 on 博客</title>
    <link>https://huangruiying.github.io/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</link>
    <description>Recent content in 框架学习 on 博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 13 Jul 2023 14:01:20 +0800</lastBuildDate><atom:link href="https://huangruiying.github.io/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>0x01.检测当前方法事物情况</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/springframework/0x01.%E6%A3%80%E6%B5%8B%E5%BD%93%E5%89%8D%E6%96%B9%E6%B3%95%E4%BA%8B%E7%89%A9%E6%83%85%E5%86%B5/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/springframework/0x01.%E6%A3%80%E6%B5%8B%E5%BD%93%E5%89%8D%E6%96%B9%E6%B3%95%E4%BA%8B%E7%89%A9%E6%83%85%E5%86%B5/</guid>
      <description>方法一:可以通过 TransactionSynchronizationManager#isActualTransactionActive 进行事物情况的判断。
public class TransactionTest{ @Test @Transactional public void test1(){ // 存在 @Transactional 注解时，返回 true; boolear isOpen = TransactionSynchronizationManager.isActualTransactionActive(); } @Test public void test2() { // 删除 @Transactional 注解时，返回 false; boolear isOpen = TransactionSynchronizationManager.isActualTransactionActive(); } } 方法二:可以通过 TransactionSynchronizationRegistry 检测是否存在事物。
import javax.transaction.Status; import javax.transaction.TransactionManager; import javax.transaction.TransactionSynchronizationRegistry; public class TransactionExample { private TransactionManager transactionManager; private TransactionSynchronizationRegistry synchronizationRegistry; public boolean isTransactionActive() { int transactionStatus = synchronizationRegistry.getTransactionStatus(); return transactionStatus == Status.STATUS_ACTIVE; } } </description>
    </item>
    
    <item>
      <title>功能-拦截器</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/springframework/%E5%8A%9F%E8%83%BD-%E6%8B%A6%E6%88%AA%E5%99%A8/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/springframework/%E5%8A%9F%E8%83%BD-%E6%8B%A6%E6%88%AA%E5%99%A8/</guid>
      <description>本文旨在SpringBoot中如何创建一个拦截器。
/** * 定义拦截器 */ @Component @Slf4j public class SelfDefineHandlerInterceptor extends HandlerInterceptorAdapter { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 自定义操作 return true; } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception { // 自定义操作 } } @Configuration public class SelfDefineWebMvcConfigurerAdapter extends WebMvcConfigurationSupport { /** * 注册拦截器 */ @Autowired private SelfDefineHandlerInterceptor selfDefineHandlerInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { // 注册拦截器 registry.</description>
    </item>
    
    <item>
      <title>框架接口-HandlerMethodArgumentResolver-学习</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/springframework/%E6%A1%86%E6%9E%B6%E6%8E%A5%E5%8F%A3-handlermethodargumentresolver-%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/springframework/%E6%A1%86%E6%9E%B6%E6%8E%A5%E5%8F%A3-handlermethodargumentresolver-%E5%AD%A6%E4%B9%A0/</guid>
      <description>HandlerMethodArgumentResolver 是SpringBoot的一个扩展接口，用于解析操作方法参数，由于其只是一个规则定义与数据获取的组件，所以若想使用，还需要知道目标范围，故一般配合拦截器使用。
该接口中一共存在两个方法:
supportsParameter: 作用是匹配规则，当满足本方法的规则时，会执行resolveArgument。 resolveArgument: 作用是具体解析/操作参数。 使用方式 以注入操作用户信息到Controller方法为例
前置条件：需要通过拦截器在请求头拿到token/用户信息，并放入线程副本供后续操作使用。 实现HandlerMethodArgumentResolver接口 public class ContextUserArgumentResolver implements HandlerMethodArgumentResolver { @Override public boolean supportsParameter(@NotNull MethodParameter parameter) { // 判断参数是否是用户信息类型，判断依据(被InjectContextUser注解标记，或者类型为ContextUser) return findMethodAnnotation(InjectContextUser.class, parameter) != null || parameter.getParameterType().isAssignableFrom(ContextUser.class); } @Override public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception { // 通过上下文获取当前用户信息 return ContextHolder.getContext().getContextUser(); } /** * 判断参数是否包含指定注解，若包含，则返回该注解。 * * @param clazz 注解类型 * @param parameter 参数对象 * @return 参数标记的注解对象 */ private &amp;lt;T extends Annotation&amp;gt; T findMethodAnnotation(Class&amp;lt;T&amp;gt; clazz, MethodParameter parameter) { T annotation = parameter.</description>
    </item>
    
    <item>
      <title>0x02.Mapstruct用法</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/mapstruct/0x02.mapstruct%E7%94%A8%E6%B3%95/</link>
      <pubDate>Mon, 10 Jul 2023 18:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/mapstruct/0x02.mapstruct%E7%94%A8%E6%B3%95/</guid>
      <description>Bean 转 DTO 示例 /** * bean */ public class Car { private String make; private int numberOfSeats; private CarType type; //constructor, getters, setters etc. } /** * dto */ public class CarDto { private String make; private int seatCount; private String type; //constructor, getters, setters etc. } // 第一步：使用 org.mapstruct.Mapper 注解，标记为映射接口。 @Mapper public interface CarMapper { CarMapper INSTANCE = Mappers.getMapper( CarMapper.class ); // 第二步：定义映射方法，明确入参的「源」对象bean，和返回的「目标」对象dto @Mapping(source = &amp;#34;numberOfSeats&amp;#34;, target = &amp;#34;seatCount&amp;#34;) CarDto carToCarDto(Car car); } Maven 依赖 &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>0x01.Mapstruct介绍</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/mapstruct/0x01.mapstruct%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 10 Jul 2023 17:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/mapstruct/0x01.mapstruct%E4%BB%8B%E7%BB%8D/</guid>
      <description>官网解释 what? 这是什么
代码生成器，基于配置方法的约定，简化不同 Java Bean 间映射与转换。 映射关系以普通代码维护，因此快速、类型安全且易于理解。 why? 出现的原因
多层应用程序通常需要在不同的对象模型（例如实体和 DTO）之间进行映射。编写这样的映射代码是一项繁琐且容易出错的任务。MapStruct旨在通过尽可能自动化来简化这项工作。 与其他映射框架相比，MapStruct在编译时生成bean映射，这确保了高性能，允许快速的开发人员反馈和彻底的错误检查。 How?
MapStruct是一个注释处理器，它插入Java编译器，可以在命令行构建（Maven，Gradle等）以及您首选的IDE中使用。 MapStruct使用合理的默认值，但在配置或实现特殊行为时会让你不碍事。 了解更多&amp;hellip;</description>
    </item>
    
  </channel>
</rss>
