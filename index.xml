<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>博客</title>
    <link>https://huangruiying.github.io/</link>
    <description>Recent content on 博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Mon, 18 Mar 2024 16:45:40 +0800</lastBuildDate><atom:link href="https://huangruiying.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>照片幻灯片</title>
      <link>https://huangruiying.github.io/projects/photography/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/projects/photography/</guid>
      <description>照片幻灯片标题 照片幻灯片内容内容内容内容内容内容内容</description>
    </item>
    
    <item>
      <title>微信提供服务的接口</title>
      <link>https://huangruiying.github.io/projects/design/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/projects/design/</guid>
      <description>查询API调用额度
POST https://api.weixin.qq.com/cgi-bin/openapi/quota/get?access_token=ACCESS_TOKEN Content-Type: application/json { &amp;#34;cgi_path&amp;#34;:&amp;#34;/wxa/gettemplatedraftlist&amp;#34; } </description>
    </item>
    
    <item>
      <title>幻灯片图文介绍多图</title>
      <link>https://huangruiying.github.io/projects/writing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/projects/writing/</guid>
      <description>幻灯片图文介绍多图
幻灯片图文介绍多图</description>
    </item>
    
    <item>
      <title>Grafana教程 - 数据打点与上报</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/grafana-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E6%95%B0%E6%8D%AE%E6%89%93%E7%82%B9%E4%B8%8E%E4%B8%8A%E6%8A%A5/</link>
      <pubDate>Mon, 18 Mar 2024 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/grafana-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E6%95%B0%E6%8D%AE%E6%89%93%E7%82%B9%E4%B8%8E%E4%B8%8A%E6%8A%A5/</guid>
      <description>数据上报 上报多数据 // 以该种格式上报数据后，时序数据库会多 payType tradeType url 这三列 Map&amp;lt;String, String&amp;gt; tag = Maps.newHashMap(); tag.put(&amp;#34;payType&amp;#34;, String.valueOf(payDetail.getPayType())); tag.put(&amp;#34;tradeType&amp;#34;, String.valueOf(payDetail.getTradeType())); tag.put(&amp;#34;url&amp;#34;, &amp;#34;/services/url/target&amp;#34;); 异常打点 Monitor.recordMany(&amp;ldquo;aggregation_pay_error&amp;rdquo;,1,tagMap);
耗时打点 Stopwatch stopwatch = Stopwatch.createStarted(); Monitor.recordTime(&amp;ldquo;aggregation_pay&amp;rdquo;, stopwatch.elapsed(TimeUnit.MILLISECONDS), tagMap);
查询上报数据 根据 payType tradeType avg by(payType,tradeType) (aggregation_pay{tradeType!=&amp;ldquo;sc&amp;rdquo;,name=&amp;ldquo;payws&amp;rdquo;,quantile=&amp;ldquo;0.95&amp;rdquo;})
耗时配置 avg by(payType,tradeType) (union_pay{tradeType!=&amp;ldquo;sc&amp;rdquo;,name=&amp;ldquo;payws&amp;rdquo;,quantile=&amp;ldquo;0.95&amp;rdquo;})
每分钟流量 sum by(payType) (rate(settlement_req_failed_count{name=&amp;ldquo;payws&amp;rdquo;}[1m]))</description>
    </item>
    
    <item>
      <title>Redission - 配置及使用</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/redission/redission%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Mon, 18 Mar 2024 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/redission/redission%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</guid>
      <description>&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.redisson&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;redisson&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.17.6&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; import org.redisson.Redisson; import org.redisson.api.RLock; import org.redisson.api.RedissonClient; import org.redisson.config.Config; import org.redisson.config.SingleServerConfig; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.stereotype.Component; import java.util.concurrent.TimeUnit; @Component public class RedissonConfig { @Value(&amp;#34;${spring.redis.host:10.10.18.4}&amp;#34;) private String host; @Value(&amp;#34;${spring.redis.port:6379}&amp;#34;) private String port; @Value(&amp;#34;${spring.redis.password:fZfX&amp;amp;POXar#RY**h}&amp;#34;) private String password; @Bean public RedissonClient redisson(){ Config config = new Config(); SingleServerConfig ssc = config.useSingleServer(); ssc.setAddress(&amp;#34;redis://&amp;#34; + host + &amp;#34;:&amp;#34; + port) .setPassword(password); return Redisson.create(config); } private static RedissonClient redissonClient; public static void main(String[] args) throws InterruptedException { RLock lock = redissonClient.</description>
    </item>
    
    <item>
      <title>Redission - 续锁流程</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/redission/redission%E7%BB%AD%E9%94%81%E7%9C%8B%E9%97%A8%E7%8B%97/</link>
      <pubDate>Mon, 18 Mar 2024 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/redission/redission%E7%BB%AD%E9%94%81%E7%9C%8B%E9%97%A8%E7%8B%97/</guid>
      <description>解决了锁超时后因未处理完任务导致其他机器抢占锁的情况
@startuml title Redission续锁流程 start :tryLock(); :tryAcquire(); :tryAcquireAsync(); switch(tryAcquireAsync: leaseTime(锁超时时间)) case(&amp;gt;0L 自定义超时时间逻辑) :设置锁超时时间为leaseTime; :。。。; case(&amp;lt;=0L 续期逻辑) :scheduleExpirationRenewal() 进行续期; :renewExpiration() 启动定时器,每1/3锁租期,执行一次续期;续期30s :调用 renewExpirationAsync() 进行续期; if (判断条件2) then (是) :符合判断条件2; stop else (否) :不符合; endif endswitch :准备结束; stop @enduml </description>
    </item>
    
    <item>
      <title>TesseractOCR教程 - 安装</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/tesseractocr-%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 18 Mar 2024 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/tesseractocr-%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description>git clone &amp;ndash;branch 4.0.0-beta.1 https://github.com/tesseract-ocr/tesseract.git
安装 安装tesseract-ocr编译依赖 yum install autoconf automake libtool -y
安装图像解析包 可以自己搭配格式 yum install libjpeg-devel libpng-devel libtiff-devel zlib-devel -y
安装图像处理与图像分析工具，tesseract依赖于它 wget http://www.leptonica.org/source/leptonica-1.74.4.tar.gz ./configure
make
make install
检查是否生成liblept动态链接库 默认位置/usr/local/lib find / -name liblept*
准备安装tesseract-ocr ./autogen.sh
./configure
make
make install
ldconfig
问题： java使用tess4j时在win环境可能会出现
- java.lang.UnsatisfiedLinkError: 找不到指定的模块
的问题，主要原因是在Windows环境下，gsdll64.dll,liblept170.dll,libtesseract304.dll等三个文件是通过vc2013编译的。 点击**此处**进行安装。
Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Handler dispatch failed; nested exception is java.lang.UnsatisfiedLinkError: Unable to load library &#39;tesseract&#39;: Native library (linux-x86-64/libtesseract.</description>
    </item>
    
    <item>
      <title>TesseractOCR教程 - 训练</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/tesseractocr-%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/</link>
      <pubDate>Mon, 18 Mar 2024 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/tesseractocr-%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/</guid>
      <description>1. 使用 tesseract hui.png hui -l chi_sim -psm 10
2. 生成.tif文件
3. --生成box文件 --[lang].[fontname].exp[num].tif --其中lang为语言名称，fontname为字体名称，num为序号，可以随便定义 最好按照这个规则 tesseract huiyi.tif huiyi batch.nochop makebox tesseract huiyi.tif huiyi -l chi_sim -psm 10 batch.nochop makebox tesseract lang.font.exp0.tif lang.font.exp0 batch.nochop makebox 4. --生成.tr文件 tesseract huiyi.tif huiyi nobatch box.train tesseract huiyi.tif huiyi -psm 10 nobatch box.train tesseract lang.font.exp0.tif lang.font.exp0.tif nobatch box.train 5. --生成unicharset unicharset_extractor huiyi.box unicharset_extractor lang.font.exp0.box 6. --创建font_properties文件 --字体名字 倾斜 加粗 固定宽度 衬线体 哥特字体 --除了字体之外其他的值都是bool值，0或1 echo font 0 0 0 0 0 &amp;gt; font_properties ======================</description>
    </item>
    
    <item>
      <title>1.Doris 基本介绍与安装</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/doris-%E6%95%B0%E4%BB%93/1.doris-%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E7%A1%80%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 13 Mar 2024 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/doris-%E6%95%B0%E4%BB%93/1.doris-%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E7%A1%80%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</guid>
      <description>官网 https://doris.incubator.apache.org/zh-CN/docs/data-table/data-model
blog https://www.pianshen.com/article/5340902459/</description>
    </item>
    
    <item>
      <title>Docker教程 - FastDFS的部署</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/docker-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8/docker%E6%95%99%E7%A8%8B-fastdfs%E7%9A%84%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Wed, 13 Mar 2024 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/docker-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8/docker%E6%95%99%E7%A8%8B-fastdfs%E7%9A%84%E9%83%A8%E7%BD%B2/</guid>
      <description>查看镜像 docker search mysql
拉取镜像 docker pull mysql:5.6
查看是否成功 docker images | grep mysql
启动 docker rm $(docker ps -a -q) docker run -m 500m -d --name ryan_mysql -p 3306:3306 -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=hry920311. docker.io/mysql:5.6 docker run -d --name ryan_mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root docker.io/mysql:5.6 bash
进入数据库 docker exec -it [ryan_mysql] bash
错误 /usr/bin/docker-current: Error response from daemon: driver failed programming external connectivity on endpoint mysql1 (6e5461f607ea31b5a9b88ab041cdef538758bb6420c46fd450e3ad9800f78810): (iptables failed: iptables &amp;ndash;wait -t nat -A DOCKER -p tcp -d 0/0 &amp;ndash;dport 3306 -j DNAT &amp;ndash;to-destination 172.</description>
    </item>
    
    <item>
      <title>Docker教程 - MySQL的部署</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/docker-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8/docker%E6%95%99%E7%A8%8B-mysql%E7%9A%84%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Wed, 13 Mar 2024 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/docker-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8/docker%E6%95%99%E7%A8%8B-mysql%E7%9A%84%E9%83%A8%E7%BD%B2/</guid>
      <description>部署 查看镜像 docker search mysql
拉取镜像 docker pull mysql:5.6
查看是否成功 docker images | grep mysql
启动 docker rm $(docker ps -a -q) docker run -m 500m -d --name ryan_mysql -p 3306:3306 -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=hry920311. docker.io/mysql:5.6 docker run -d --name ryan_mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root docker.io/mysql:5.6 bash
启动脚本 #!/bin/bash # # author: huangruiying # -------------------- # docker(mysql) runner # -------------------- # 1.stop docker stop ryan_mysql # 2.</description>
    </item>
    
    <item>
      <title>Docker教程 - 基础的安装与使用</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/docker-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8/docker%E6%95%99%E7%A8%8B-%E5%9F%BA%E7%A1%80%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 13 Mar 2024 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/docker-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8/docker%E6%95%99%E7%A8%8B-%E5%9F%BA%E7%A1%80%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description>1.安装docker 安装 yum install docker-io -y
查看版本 docker -v
启动 service docker start
设置开机启动 chkconfig docker on
2.配置docker 因为国内访问 Docker Hub 较慢, 可以使用腾讯云提供的国内镜像源, 加速访问 Docker Hub
设置docker库 echo &amp;#34;OPTIONS=&amp;#39;--registry-mirror=https://mirror.ccs.tencentyun.com&amp;#39;&amp;#34; &amp;gt;&amp;gt; /etc/sysconfig/docker systemctl daemon-reload service docker restart 3.docker实操 下载镜像 docker pull centos
查看当前镜像列表 （解释列信息） docker images
REPOSITORY TAG IMAGE ID CREATED SIZE REPOSITORY TAG IMAGE ID CREATED SIZE docker.io/centos latest 75835a67d134 6 weeks ago 200 MB 拓展： docker images --format &amp;quot;table {{.</description>
    </item>
    
    <item>
      <title>Docker教程 - 进入容器的脚本</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/docker-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8/docker%E6%95%99%E7%A8%8B-%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E7%9A%84%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Wed, 13 Mar 2024 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/docker-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8/docker%E6%95%99%E7%A8%8B-%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E7%9A%84%E8%84%9A%E6%9C%AC/</guid>
      <description>#!/bin/bash # author: huangruiying # 通过容器名称进入容器 enter_container.sh # -------------------------------------------- # $0 : filename # $n : get param value by n(param index) # $* : param array # $# : param count # -------------------------------------------- # docker exec script # -------------------------------------------- function hit_container_name(){ echo -e &amp;#34;&amp;gt;&amp;gt;&amp;gt; find $1 from current running container list !&amp;#34; running_container_names=$(docker ps --format &amp;#34;table {{.Names}}&amp;#34;) for i in $running_container_names do if [[ $i == &amp;#34;$1&amp;#34; ]] then echo -e &amp;#34;&amp;gt;&amp;gt;&amp;gt; hit container $1 !</description>
    </item>
    
    <item>
      <title>ELSearch - 基础的安装与使用</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/elsearch-%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%BC%95%E6%93%8E/elsearch-%E5%9F%BA%E7%A1%80%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 13 Mar 2024 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/elsearch-%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%BC%95%E6%93%8E/elsearch-%E5%9F%BA%E7%A1%80%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description> 软件下载 # curl curl -L -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.3.2.tar.gz # wget wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.3.2.tar.gz.sha512 # yum yum install perl-Digest-SHA # 解决shasum在centos执行不了的问题。 shasum -a 512 -c elasticsearch-6.3.2.tar.gz.sha512 tar -xvf elasticsearch-6.3.2.tar.gz cd elasticsearch-6.3.2/bin 启动服务 # 启动（默认监听9200端口） ./elasticsearch # 后台运行 ./elasticsearch -d # 后台运行并记录pid到文件 ./elasticsearch -d -p ./elasticsearch.pid # 关闭 kill `cat elasticsearch.pid ` </description>
    </item>
    
    <item>
      <title>Fernflower - Java反编译工具使用说明</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/fernflower-%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/fernflower-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Wed, 13 Mar 2024 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/fernflower-%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/fernflower-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</guid>
      <description>GitHub GUI
Fernflower is an easy to use yet advanced cli Java decompiler.
下载fernflower.jar文件
使用方式:
java -jar fernflower.jar jarToDecompilePackage.jar decompile_output/ </description>
    </item>
    
    <item>
      <title>MySQL安装</title>
      <link>https://huangruiying.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%89%E8%A3%85/</link>
      <pubDate>Wed, 13 Mar 2024 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%89%E8%A3%85/</guid>
      <description>安装 brew install mysql@5.7 https://downloads.mysql.com/archives/community/
启动 sudo /usr/local/mysql-5.6.10-osx10.7-x86_64/bin/mysqld &amp;ndash;user=mysql
初始登陆 mysql -u root -p
重置密码 root用户密码重置为root123 set password for root@localhost = password(&amp;lsquo;root123&amp;rsquo;);
创建数据库 colorful create database colorful charset=utf8 ;
进入数据库 colorful use colorful;
在库 colorful 内创建一张表 c_test CREATE TABLE c_test ( id bigint(20) NOT NULL AUTO_INCREMENT COMMENT &amp;lsquo;主键&amp;rsquo;, name varchar(100) NOT NULL COMMENT &amp;lsquo;姓名&amp;rsquo;, age int DEFAULT 1 COMMENT &amp;lsquo;年龄&amp;rsquo;, PRIMARY KEY (id), KEY idx_name (name) ) ENGINE=InnoDB AUTO_INCREMENT=30 DEFAULT CHARSET=utf8 COMMENT=&amp;lsquo;测试表&amp;rsquo;</description>
    </item>
    
    <item>
      <title>创建对象控制：控制某类可以创建的对象个数</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%8E%A7%E5%88%B6%E6%8E%A7%E5%88%B6%E6%9F%90%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Fri, 26 Jan 2024 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%8E%A7%E5%88%B6%E6%8E%A7%E5%88%B6%E6%9F%90%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%AA%E6%95%B0/</guid>
      <description></description>
    </item>
    
    <item>
      <title>结构型模式-组合模式</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 28 Dec 2023 10:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid>
      <description> 核心思想 使用场景 实现思路 区别对比 </description>
    </item>
    
    <item>
      <title>ShardingSphere针对高级语法DUPLICATE KEY的使用</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/shardingsphere/0x03.shardingsphere%E9%92%88%E5%AF%B9%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95duplicate-key%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 20 Dec 2023 15:51:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/shardingsphere/0x03.shardingsphere%E9%92%88%E5%AF%B9%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95duplicate-key%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ShardingSphere接入问题汇总</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/shardingsphere/0x02.shardingsphere%E6%8E%A5%E5%85%A5%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</link>
      <pubDate>Wed, 20 Dec 2023 15:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/shardingsphere/0x02.shardingsphere%E6%8E%A5%E5%85%A5%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</guid>
      <description>czb_payment.xxxxxx not found 表找不到，注意分表配置，是否有数据源前缀
Error updating database. Cause: org.apache.shardingsphere.underlying.common.exception.ShardingSphereException: INSERT INTO &amp;hellip;. ON DUPLICATE KEY UPDATE can not support update for sharding column. INSERT INTO &amp;hellip;. ON DUPLICATE KEY UPDATE can not support update for sharding column. 使用DUPLICATE KEY语法时，需要把sharding列忽略掉。在AbstractMethod子类内，构建update时忽略即可。</description>
    </item>
    
    <item>
      <title>SpringBoot-功能实现-方法参数注入</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5/</link>
      <pubDate>Thu, 30 Nov 2023 16:07:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5/</guid>
      <description>问题一：如何使用Spring框架的能力，在下述方法中，对 user 进行数据注入。（即：解析请求携带的用户信息，并填充到user参数）
public Wrapper&amp;lt;Void&amp;gt; edit(@RequestBody BizRequest request, ContextUser user) { // todo return WrapMapper.ok(); } 问题二：哪些方法可以注入?
被拦截的方法范围是什么，如何控制。</description>
    </item>
    
    <item>
      <title>0x01.EasyExcel极速模式的开启与使用</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/easyexcel/0x02.easyexcel%E6%9E%81%E9%80%9F%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BC%80%E5%90%AF%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 10 Nov 2023 18:17:11 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/easyexcel/0x02.easyexcel%E6%9E%81%E9%80%9F%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BC%80%E5%90%AF%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description> EasyExcel默认大文件处理方案 默认大文件处理会自动判断，共享字符串5M以下会使用内存存储，大概占用15-50M的内存,超过5M则使用文件存储，然后大概会存储10批，每批100条，共20000条的临时数据在内存。除了共享字符串占用内存外，其他占用较少，所以可以预估2M，所以默认大概20M就能读取一个超级大的文件。 极速模式开启方式 // 若excel不是很大，30m以下，不会有高并发，机器内存也比较大，官方认为可以开启极速模式 // 极速模式会强制使用内存存储；这样大概一个20M的excel使用150M的内存、会创建很多临时对象，所以100M会一直GC。 // 效率会比默认大文件处理方案高 EasyExcel.read().readCache(new MapCache()); </description>
    </item>
    
    <item>
      <title>0x01.EasyExcel使用时的问题</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/easyexcel/0x03.easyexcel%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 10 Nov 2023 18:17:11 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/easyexcel/0x03.easyexcel%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description> 读不到数据 以类文件作为文件头，使用注解解析文件时，发现配置的没问题，但是就是读不到数据！ 确认字符集编码，尝试调整字符集编码。(ModelBuildEventListener#invoke 拿到的数据是乱码，导致映射失败) </description>
    </item>
    
    <item>
      <title>0x01.Swagger插件集成</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/swagger/0x01.swagger%E6%8F%92%E4%BB%B6%E9%9B%86%E6%88%90/</link>
      <pubDate>Fri, 10 Nov 2023 18:17:11 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/swagger/0x01.swagger%E6%8F%92%E4%BB%B6%E9%9B%86%E6%88%90/</guid>
      <description>依赖引入 &amp;lt;!-- swagger--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.8.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 第三方 swagger-ui--&amp;gt; &amp;lt;!-- 文档地址：http://localhost:8085/doc.html--&amp;gt; &amp;lt;!-- 数据接口：http://localhost:8085/v2/api-docs--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.github.xiaoymin&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;swagger-bootstrap-ui&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.9.6&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 插件配置 package czb.settle.ledger.core.config.application; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.core.env.Environment; import org.springframework.core.io.ClassPathResource; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.handler.SimpleUrlHandlerMapping; import org.springframework.web.servlet.resource.PathResourceResolver; import org.springframework.web.servlet.resource.ResourceHttpRequestHandler; import org.springframework.web.util.UrlPathHelper; import springfox.documentation.annotations.ApiIgnore; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.ParameterBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.</description>
    </item>
    
    <item>
      <title>0x01.联动Swagger进行接口导入</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/yapi/0x01.%E8%81%94%E5%8A%A8swagger%E8%BF%9B%E8%A1%8C%E6%8E%A5%E5%8F%A3%E5%AF%BC%E5%85%A5/</link>
      <pubDate>Fri, 10 Nov 2023 18:17:11 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/yapi/0x01.%E8%81%94%E5%8A%A8swagger%E8%BF%9B%E8%A1%8C%E6%8E%A5%E5%8F%A3%E5%AF%BC%E5%85%A5/</guid>
      <description> 手动导入配置路径 数据管理 -- 开启url导入 -- 输入框配置swagger数据接口地址(http://localhost:8085/v2/api-docs) 自动同步配置路径 设置 -- swagger自动同步 -- 打卡开关并配置相关信息 </description>
    </item>
    
    <item>
      <title>0x01.引入EasyExcel及基础读取使用</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/easyexcel/0x01.%E5%BC%95%E5%85%A5easyexcel%E5%8F%8A%E5%9F%BA%E7%A1%80%E8%AF%BB%E5%8F%96%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 10 Nov 2023 18:17:11 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/easyexcel/0x01.%E5%BC%95%E5%85%A5easyexcel%E5%8F%8A%E5%9F%BA%E7%A1%80%E8%AF%BB%E5%8F%96%E4%BD%BF%E7%94%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>GeoHash地理算法</title>
      <link>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/geohash/geohash%E5%9C%B0%E7%90%86%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 10 Oct 2023 16:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/geohash/geohash%E5%9C%B0%E7%90%86%E7%AE%97%E6%B3%95/</guid>
      <description>GeoHash算法基本思想：将经纬度编码，把二维坐标转换为一维，一般情况下，精确到小数点后6位可以达到约1米精度，所以取到小数点后第六位即可。
地球经度范围是东经180到西经180，纬度范围是南纬90到北纬90；
我们设定西经为负，南纬为负，所以地球上的经度范围就是[-180 西， 180 东]，纬度范围就是[-90 南，90 北]。
东经:116°23′17〃,北纬:39°54′27〃 116.388056 , 39.907500
以上述经纬度坐标进行逼近编码，进行算法计算过程说明
对纬度坐标 39.987612 的逼近过程：
首先，将纬度区间[-90,90]进行分割，生成[-90,0),[0,90]左右两区间。坐标符合左区间，计作0，符合右区间，计作1。本case符合右区间，记1。 其次，将符合的区间[0,90]进行第二次分割，生成[0,45),[45,90]左右两区间。本case符合左区间，记0。 接着，将符合的区间[0,45)进行第二次分割，生成[0,22.5),[22.5,45)左右两区间。本case符合右区间，记1。 ... 分割n次后，区间会越来逼近纬度坐标 39.987612 将逼近后的编码记录，假设为 10011111 对经度也左同样操作，只不过区间是[-180,180]
经度的编码记录，假设为 11010000 将经纬两串编码进行组合，奇数位方经度，偶数位放纬度，假设新串为 1110 0011 0101 0101，16进制编码为 E355 ，即为坐标的GeoHash值。表示的区间是最后一次逼近的经纬度范围。 所以，逼近的次数越多，GeoHash表示的范围越小。
function change(){ // 39°54′27〃 转换为 39.9075 var d = &amp;ldquo;39&amp;rdquo;; var f = &amp;ldquo;54&amp;rdquo;; var m = &amp;ldquo;27&amp;rdquo;; // 秒/60 = 分 // 分/60 = 度 // 将秒化成分，与分累加后，再化成度，即得出结果 var f = parseFloat(f) + parseFloat(m/60); var du = parseFloat(f/60) + parseFloat(d); console.</description>
    </item>
    
    <item>
      <title>0x04.支付通道自动上下线</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/0x04.%E6%94%AF%E4%BB%98%E9%80%9A%E9%81%93%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/</link>
      <pubDate>Mon, 09 Oct 2023 09:50:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/0x04.%E6%94%AF%E4%BB%98%E9%80%9A%E9%81%93%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/</guid>
      <description>探活相关逻辑 1。通道下线
2。探活结果确认：探活成功率计算与状态变更。
本轮成功率计算；扫描探活中、且无可用探活单额度的record，通过log表，获取到所有探活单号，进行成功率计算（前提保证所有探活单都到达终态）。 探活成功；恢复通道上线状态(在探活表标记当前记录无效、状态探活成功)，并发送恢复通知。 探活失败；标记record状态为探活完成，等待「探活轮次推进」任务推进当前记录。 3。探活轮次推进：
扫描探活完成，但是未探活成功、且需要继续探活的record。判断推进到探活失败/下轮探活中。 探活失败；判断探活轮次&amp;gt;探活执行最大轮数时，标记通道探活失败，并发出通道不再探活的告警。 下轮探活中；初始化下一轮探活开始时间、可用探活单数目、已经探活的轮次+1、标记状态为探活中。 探活表结构 CREATE TABLE `pay_channel_probe` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &amp;#39;主键ID&amp;#39;, `channel_id` int(11) DEFAULT NULL COMMENT &amp;#39;通道ID&amp;#39;, `probe_start_time` datetime DEFAULT NULL COMMENT &amp;#39;探活开始时间;探活开始时间&amp;#39;, `cycle_probe_start_time` datetime DEFAULT NULL COMMENT &amp;#39;本轮探活开始时间;本轮探活开始时间&amp;#39;, `probe_status` int(2) DEFAULT NULL COMMENT &amp;#39;状态;1-探活中 2-已完成本轮探活 3-探活成功 4-探活失败&amp;#39;, `probe_total_issue_num` int(11) DEFAULT NULL COMMENT &amp;#39;探活发放单数;每轮发放探活单的数量&amp;#39;, `probe_available_issue_num` int(11) DEFAULT NULL COMMENT &amp;#39;本轮可用探活单数;本轮探活还可以发多少探活单&amp;#39;, `success_threshold` decimal(10, 6) DEFAULT NULL COMMENT &amp;#39;成功率阈值;达到该值时，通道恢复&amp;#39;, `history_threshold` varchar(256) DEFAULT NULL COMMENT &amp;#39;历史每轮探活的成功率记录&amp;#39;, `probe_execute_count` int(4) DEFAULT NULL COMMENT &amp;#39;探活执行轮数;从当前通道下线到目前为止，共经历了几次探活&amp;#39;, `probe_execute_max_count` int(4) DEFAULT NULL COMMENT &amp;#39;探活执行最大轮数;当前通道下线后最多要经历多少轮探活&amp;#39;, `create_time` datetime DEFAULT NULL COMMENT &amp;#39;创建时间;创建时间&amp;#39;, `update_time` datetime DEFAULT NULL COMMENT &amp;#39;更新时间;更新时间&amp;#39;, `yn` tinyint(4) DEFAULT NULL COMMENT &amp;#39;是否有效;1 有效，0，无效，探活成功后置为0&amp;#39;, PRIMARY KEY (`id`), KEY `idx_channel_yn` (`channel_id`, `yn`), KEY `idx_enable_status` (`yn`) ) COMMENT = &amp;#39;已下线通道探活表&amp;#39;; CREATE TABLE `pay_channel_probe_log` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &amp;#39;主键&amp;#39;, `probe_id` bigint(20) DEFAULT NULL COMMENT &amp;#39;探活通道id&amp;#39;, `probe_start_time` datetime DEFAULT NULL COMMENT &amp;#39;探活开始时间;对应 cycle_probe_start_time&amp;#39;, `order_no` varchar(64) DEFAULT NULL COMMENT &amp;#39;探活单号;订单号&amp;#39;, `create_time` datetime DEFAULT NULL COMMENT &amp;#39;创建时间&amp;#39;, `update_time` datetime DEFAULT NULL COMMENT &amp;#39;更新时间&amp;#39;, PRIMARY KEY (`id`), KEY `idx_probe_id_start_time` (`probe_id`, `probe_start_time`) ) COMMENT = &amp;#39;已下线通道探活日志表&amp;#39;; demo code import com.</description>
    </item>
    
    <item>
      <title>0x05.支付账单离线服务建设</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/0x05.%E6%94%AF%E4%BB%98%E8%B4%A6%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%BB%BA%E8%AE%BE/</link>
      <pubDate>Mon, 09 Oct 2023 09:50:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/0x05.%E6%94%AF%E4%BB%98%E8%B4%A6%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%BB%BA%E8%AE%BE/</guid>
      <description>交易账单 内部交易账单 CREATE TABLE `payment_trade_bill_2023_11` ( `id` bigint(20) unsigned NOT NULL COMMENT &amp;#39;数据主键&amp;#39;, `pay_sn` varchar(128) NOT NULL DEFAULT &amp;#39;&amp;#39; COMMENT &amp;#39;支付单号&amp;#39;, `order_no` varchar(128) NOT NULL DEFAULT &amp;#39;&amp;#39; COMMENT &amp;#39;业务订单号（支付单、退款单）&amp;#39;, `pay_channel_sn` varchar(128) NOT NULL DEFAULT &amp;#39;&amp;#39; COMMENT &amp;#39;支付通道流水号&amp;#39;, `pay_channel_type` int(4) NOT NULL COMMENT &amp;#39;通道类型: 微信、支付宝、京东&amp;#39;, `pay_channel_product` varchar(32) NOT NULL DEFAULT &amp;#39;&amp;#39; COMMENT &amp;#39;支付产品: (小程序 app h5 sm sc)&amp;#39;, `biz_channel_sn` varchar(128) NOT NULL DEFAULT &amp;#39;&amp;#39; COMMENT &amp;#39;业务渠道流水号&amp;#39;, `biz_channel_code` varchar(16) DEFAULT NULL COMMENT &amp;#39;业务渠道编码&amp;#39;, `trade_type` int(2) NOT NULL COMMENT &amp;#39;交易类型: 支付、退款&amp;#39;, `trade_amount` decimal(10, 2) NOT NULL DEFAULT &amp;#39;0.</description>
    </item>
    
    <item>
      <title>SpringBoot-功能实现-编程式事务</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Thu, 07 Sep 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1/</guid>
      <description> Spring支持声明式事务管理和编程式事务管理两种方式。 声明式事务管理,即我们常用的 @Transactional 注解。 声明式事务基于切面实现的。本质是对方法前后进行拦截，然后在目标方法开始之前会创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。
优点是 使用方便，清晰。 缺点是 不能精细控制事物粒度，即一个方法中包含6条查询语句，1次网络请求，2条更新语句，那么方法使用注解时就很可能出行长事物，导致db性能降低。 开启事物需要依赖Spring切面，即使用Spring容器获取对象后，调用public的、标记事物注解的方法才能生效。 编程式事物管理,即我们常用的 注入TransactionTemplate 方式（或者PlatformTransactionManager）。 1. 优点是 可以精细控制事物粒度 2. 缺点是 编码复杂 编程式事物 TransactionTemplate 介绍 afterPropertiesSet 非空校验(PlatformTransactionManager) execute: 开启事物并包含了执行操作db的逻辑 PlatformTransactionManager#getTransaction 开启事物 PlatformTransactionManager#commit 提交事物 rollbackOnException PlatformTransactionManager#rollback 异常时回滚 事物挂起 数据库事物状态中不包含挂起状态; 目前数据库事物状态包括: 活动状态，部分提交状态，失败状态，中止状态，提交状态。 挂起当前事务是Spring提供的功能; 挂起的目的是释放持有的资源，将当前连接与线程解绑，保存当前连接，以便将来恢复。 由于Spring事物挂起期间没有释放数据库连接，所以会影响数据库性能。 使用编程式事物的时候，若需要临时挂起事物，可以进行如下操作: TransactionTemplate#setRollbackOnly PlatformTransactionManager#suspend 对象 TransactionTemplate 初始化位置 TransactionAutoConfiguration#TransactionTemplateConfiguration </description>
    </item>
    
    <item>
      <title>场景下设计模式的最佳实践</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E5%AE%9E%E6%93%8D%E5%9C%BA%E6%99%AF%E4%B8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Thu, 24 Aug 2023 15:33:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E5%AE%9E%E6%93%8D%E5%9C%BA%E6%99%AF%E4%B8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid>
      <description> &amp;ndash; </description>
    </item>
    
    <item>
      <title>JVM参数: -javaagent介绍与使用</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/jvm%E5%8F%82%E6%95%B0-javaagent%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/jvm%E5%8F%82%E6%95%B0-javaagent%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description>代理 (agent) 是在你的main方法前的一个拦截器 (interceptor)，也就是在main方法执行之前，执行agent的代码。 agent的代码与你的main方法在同一个JVM中运行，并被同一个system classloader装载，被同一的安全策略 (security policy) 和上下文 (context) 所管理。
叫代理（agent）这个名字有点误导的成分，它与我们一般理解的代理不大一样。java agent使用起来比较简单。
怎样写一个java agent? 只需要实现premain这个方法
public static void premain(String agentArgs, Instrumentation inst) JDK 6 中如果找不到上面的这种premain的定义，还会尝试调用下面的这种premain定义：
public static void premain(String agentArgs) 2. Agent 类必须打成jar包，然后里面的 META-INF/MAINIFEST.MF 必须包含 Premain-Class这个属性。
下面是一个MANIFEST.MF的例子：
Manifest-Version: 1.0 Premain-Class:MyAgent1 Created-By:1.6.0_06 然后把MANIFEST.MF 加入到你的jar包中。
所有的这些Agent的jar包，都会自动加入到程序的classpath中。所以不需要手动把他们添加到classpath。 除非你想指定classpath的顺序。
一个java程序中-javaagent这个参数的个数是没有限制的，所以可以添加任意多个java agent。
所有的java agent会按照你定义的顺序执行。 例如：
java -javaagent:MyAgent1.jar -javaagent:MyAgent2.jar -jar MyProgram.jar 假设MyProgram.jar里面的main函数在MyProgram中。
MyAgent1.jar, MyAgent2.jar, 这2个jar包中实现了premain的类分别是MyAgent1, MyAgent2 程序执行的顺序将会是
MyAgent1.premain -&amp;gt; MyAgent2.premain -&amp;gt; MyProgram.main 5. 另外，放在main函数之后的premain是不会被执行的，</description>
    </item>
    
    <item>
      <title>创建型模式-抽象工厂</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/</guid>
      <description>创建型模式 创建对象的最佳方式
通过FactoryProducer 工厂创造器创建一个工厂</description>
    </item>
    
    <item>
      <title>创建型模式-建造者模式</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/todo%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/todo%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>核心思想 使用场景 对于基本部件不会变，而组合经常变化的时候。比如肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的&amp;quot;套餐&amp;quot;。 实现思路 区别对比 创建型模式 提供了创建对象的最佳方式
主要解决 复杂对象的创建工作，由于需求变化会导致复杂对象时刻面临巨大变化，但是将他们组合在一起的算法相对稳定。
如何解决 将变与不变分离开。
关键代码 建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。
应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的&amp;quot;套餐&amp;quot;。 2、JAVA 中的 StringBuilder。
优点： 1、建造者独立，易扩展。 2、便于控制细节风险。 缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。
使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。
注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</description>
    </item>
    
    <item>
      <title>创建型模式-享元模式</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid>
      <description> 核心思想（复用） 运用共享技术，针对需要大量创建的相同对象(Circle)，但对象间只有极少属性(x,y,r)有区别，所以可以重复利用一个对象，写入属性后使用。 使用场景 在有创建大量对象，可能会占用很大部分内存，导致内存溢出 或频繁GC消耗cpu。 支持工厂模式缓存 --- 大量调用工厂创建对象方法时，可以在保证对象全局变量没有线程安全问题的前提下，跳过创建，直接重复吐相同对象。 工厂类Factory&amp;lt;Type&amp;gt; 全局变量Map&amp;lt;String,Type&amp;gt; 获取对象 Map.get(Str) 查询产品中心场景 --- 大量请求涌入，条件相同时，可以使用享元，第一个对象缓存，后续直接从缓存拿数据。 实现思路(FlyweightFactory（享元工厂类）ConcreteFlyweight（具体享元类）) 我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。 区别对比 与对象池的区别 对象池化：目的是降低对象创建带来的资源消耗(预创建+动态创建+闲时回收)、对象重复使用、且同一时刻对象只被一处使用（独占）。 享元模式：用时不存在时动态创建，不回收。同一时刻同一对象可由多方使用，对象共享。 与缓存模式的区别： 缓存：主打通过存储数据，提高效率。 享元模式：主打对象的复用。 public class ShapeFactory { private static final Map&amp;lt;String, Shape&amp;gt; circleMap = new HashMap&amp;lt;&amp;gt;(); public static Shape getCircle(String color) { // 获取对象 Circle circle = (Circle) circleMap.get(color); if (circle == null) { // 不存在时写入 circle = new Circle(color); circleMap.put(color, circle); } return circle; } } </description>
    </item>
    
    <item>
      <title>获取类的所有子类</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%90%E7%B1%BB/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%90%E7%B1%BB/</guid>
      <description>// 获取类的所有子类 public static Map&amp;lt;String, T&amp;gt; getBeans(Class father) { return applicationContext.getBeansOfType(father); }</description>
    </item>
    
    <item>
      <title>结构型模式-适配器模式</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>核心思想 负责兼容差异，作为两个不兼容的接口的桥梁（适配） 将一个类的接口转换成客户希望的另外一个接口。使原本由于接口不兼容而不能一起工作的那些类可以一起工作。 主要解决在软件系统中，常常要将一些&amp;quot;现存的对象&amp;quot;放到新的环境中，而新环境要求的接口是现对象不能满足的。 使用场景 业务网关：将外部不同接口、不同字段，映射为内部标准字段 美国电器 110V，中国电器 220V，就要有一个适配器将 110V 转化为 220V JAVA 中的 jdbc。 接口兼容：通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。） 实现思路 区别对比 应用实例：
优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。
缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。 因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</description>
    </item>
    
    <item>
      <title>结构型模式-装饰器模式</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description> 核心思想 在不改变对象自身的基础上，通过对目标类的包装，实现对该类的扩展。 可以在程序动态运行期间，扩展对象功能。 一般，我们为了扩展一个类，经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。与继承相比，装饰者是一种更轻便灵活的做法 缺点是： 增加了很多小对象，增大系统复杂性，所以在项目结构上要分类好。 被多次装饰的对象，出错时不好排查。 使用场景 在不想增加很多子类的情况下扩展类，使用装饰器。 实现思路 角色：AbsDecorator、XxxDecorator AbsDecorator:抽象装饰类 XxxDecorator:实际拓展类 区别对比 与代理模式区别 代理模式：对象是代理对象创建的。 装饰器模式：对象是通过构造参数传入的。 public abstract class AbsDecorator implements 被装饰类|待扩展类 { protected 被装饰类|待扩展类 decoratedShape; public AbsDecorator(Shape decoratedShape){ this.decoratedShape = decoratedShape; } public void draw(){ decoratedShape.draw(); } } public class XxxDecorator extends AbsDecorator { public XxxDecorator(Shape decoratedShape) { super(decoratedShape); } @Override public void draw() { decoratedShape.draw(); // 扩展的功能 setRedBorder(decoratedShape); } private void setRedBorder(Shape decoratedShape){ System.out.println(&amp;#34;Border Color: Red&amp;#34;); } } </description>
    </item>
    
    <item>
      <title>内存泄露：ByteArrayOutputStream</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2bytearrayoutputstream/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2bytearrayoutputstream/</guid>
      <description>ByteArrayOutputStream</description>
    </item>
    
    <item>
      <title>三方程序漏洞：Xstream 反序列化漏洞</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/%E4%B8%89%E6%96%B9%E7%A8%8B%E5%BA%8F%E6%BC%8F%E6%B4%9Exstream-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/%E4%B8%89%E6%96%B9%E7%A8%8B%E5%BA%8F%E6%BC%8F%E6%B4%9Exstream-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</guid>
      <description>com.thoughtworks.xstream xstream 1.4.20 private static XStream createXStream(){ XStream xstream = new XStream(new DomDriver(&amp;ldquo;utf8&amp;rdquo;)); //将所有类反序列化禁用 xstream.denyTypesByWildcard(new String[]{&amp;quot;&amp;quot;}); //根据情况设置类白名单，这里将所有com.czb.paycenter.baseinfo.*类设置为白名单 xstream.allowTypesByWildcard(new String[]{&amp;ldquo;com.czb.paycenter.baseinfo.&amp;rdquo;}); return xstream; }</description>
    </item>
    
    <item>
      <title>设计模式概述</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</guid>
      <description>设计模式分为创建型模式、结构型模式、
创建型模式 工厂模式 抽象工厂模式 单例模式 原型模式 建造者模式 享元模式
结构型模式 适配器模式
开发时对于某些特定功能的类的命名规范 Wrapper、Holder、Handler、Handle、Dispatcher 傻傻分不清? - Wrapper： - Holder：持有者，比如存储线程上下文的线程副本，可以放在线程副本holder内，提供对外操作入口 - Handler：句柄，就是 - Handle：资源的抽象引用 - Dispatcher：分发器， - Classifier：分类器 VO、DTO、Request、Response 傻傻分不清 - Request: 接口调用者传入参数的载体 - DTO: 数据载体，数据在某服务、多方法间传输时使用(方法调用时的传参) - VO: 接口返回给页面的数据对象 - Response: 响应给页面的结果对象，包含VO ``` public class ParamRequest{ // 数据载体1 private RuleDTO ruleDto; // 数据载体2 private InfoDTO infoDto; } public class ResultResponse&amp;lt;T&amp;gt; implements Serializable { // 业务状态码 private String code; // 响应信息 private String message; // 数据 VO private T data; } ``` </description>
    </item>
    
    <item>
      <title>为什么不显式创建线程而是用线程池</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%BE%E5%BC%8F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E8%80%8C%E6%98%AF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%BE%E5%BC%8F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E8%80%8C%E6%98%AF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid>
      <description>不方便集中管理 无法控制数量，过多线程并行会增加系统开销，甚至hang住&amp;amp;打瘫 开销1：cpu时间片分配资源时，线程会频繁唤醒挂起 开销2：频繁创建&amp;amp;销毁线程，占用cpu资源 复用性低，不能有效发挥多线程性能（有限资源下）</description>
    </item>
    
    <item>
      <title>线程：阻塞与唤醒</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92/</guid>
      <description>JVM自身能摆平 线程的阻塞和唤醒的切换 吗? 不能！Java的线程是映射到操作系统原生线程之上的，若要阻塞或唤醒一个线程，则需 操作系统 介入。
为什么线程阻塞和唤醒的切换很消耗资源? 因为设计线程到用户态与核心态之间切换(这种切换会消耗大量的系统资源)
用户态与核心态之间切换，到底做了什么事情? 用户态与内核态都有各自专用的内存空间，专用的寄存器 用户态切换至内核态，需要传递给许多变量、参数给内核 内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。
到底什么是用户态，什么是内核态 内核态: CPU可以访问内存所有数据，包括外围设备；例如硬盘, 网卡。CPU也可以将自己从一个程序切换到另一个程序 用户态: 只能受限的访问内存，且不允许访问外围设备。占用CPU的能力被剥夺，CPU资源可以被其他程序获取
为什么需要用户态切换到核心态 限制不同程序之间的访问能力，防止程序获取其他程序的数据，防止水平越权，将信息泄漏 因此，CPU划分出两个权限等级：用户态 和 内核态</description>
    </item>
    
    <item>
      <title>行为型模式-策略模式</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/todo%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/todo%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>核心思想 通过预先创建好多种行为，为不通场景提供服务
使用场景 对接多家支付通道时，每种支付通道对接方式是一种策略
实现思路 角色：Context、AbsStrategy、ApplyStrategy Context：根据传入条件，选择具体策略 AbsStrategy：定义策略功能与部分流程，主要包含接口和抽象类 ApplyStrategy：具体的应用策略</description>
    </item>
    
    <item>
      <title>行为型模式-观察者模式</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description> 核心思想 注册观察类到被观察的对象全局观察者列表中，让被观察对象知道有哪些类在观察它的变化，从而方便被观察者通知每个自身变化到观察者列表内。 使用场景 低耦合前提下，目标对象（Subject）的状态变化，观察者对象（Observers）都要接到通知。 实现思路 角色：Subject、Observer Subject：被观察的对象 Observer：观察者集合，Subject的动作要通知到这里。 Observers(List,维护Observer的集合) notifyEveryObserver(在有通知需求时(比如状态变更)，通知到每个Observer，遍历Observer并通知) </description>
    </item>
    
    <item>
      <title>行为型模式-命令模式</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>核心思想 是一种数据驱动的设计模式，它属于行为型模式。 请求以命令的形式包裹在对象中，并传给「调用对象」。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 使用场景 需要线预定义要执行的内容、步骤，后通过触发/定时执行时，可以使用 其他没太想好 实现思路 角色：Order、Stock、Broker Order：命令接口，定义标准的执行方法；用订单举例 execute(){} Stock：请求类，整合了所有可执行的命令；用店铺举例 ApplyStock：具体的命令对象；通过实现Order接口，扩展其执行功能；包装了Stock的每一个可执行的方法(命令)；用买卖举例 implement Order private Stock stock execute(){ stock.command(); } Broker：命令调用对象，维护Orders(ApplyStocks) public interface Order { void execute(); } public class Stock { private String name = &amp;#34;ABC&amp;#34;; private int quantity = 10; public void buy(){ System.out.println(&amp;#34;Stock [ Name: &amp;#34;+name+&amp;#34;,Quantity: &amp;#34; + quantity +&amp;#34; ] bought&amp;#34;); } public void sell(){ System.out.println(&amp;#34;Stock [ Name: &amp;#34;+name+&amp;#34;,Quantity: &amp;#34; + quantity +&amp;#34; ] sold&amp;#34;); } } public class BuyStock implements Order { private Stock abcStock; public BuyStock(Stock abcStock){ this.</description>
    </item>
    
    <item>
      <title>行为型模式-模版方法模式</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
      <description> 核心思想 一个抽象类公开定义了执行它的方法的方式/模板 使用场景 多态时，在抽象类中定义标准执行流程时 可以配合策略模式使用 实现思路 角色：AbsClass、 通过抽象类，明确主流程、主框架，将可能存在差异的地方进行抽象化，供子类自定义 class AbcTemplate&amp;lt;REQ,RES&amp;gt;{ RES do(REQ request){ &amp;quot;template define info &amp;quot;.sout special().sout } // 自定义 protected String special(); } </description>
    </item>
    
    <item>
      <title>行为型模式-事件监听</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/todo%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/todo%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/</guid>
      <description>核心思想【是 观察者模式 的一种实现】 生产监听事件到事件池， 监听事件池并获取事件，去执行。
使用场景
实现思路</description>
    </item>
    
    <item>
      <title>行为型模式-状态模式</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid>
      <description> 核心思想 对象的行为依赖于对象状态。通过状态的改变，而改变对象的行为 比如一个逻辑，if(status = 1) : case 1 ; if(status = 2) : case 2 ; 使用场景 离线计算收益时各步骤独立且状态明确; 捞取数据落地(新订单生成收益单、旧收益单)-status=1； 计算status=1的收益，并更新，记status=2； 捞取status=2的数据，通知到下游系统，成功记status=3，失败status=4； 实现思路 角色：Context、AbsState、ApplyState 离线计算收益时，1 捞取数据完成 3 计算收益完成 8 发布收益完成 ProfitState // 收益计算接口 ProfitCalculateContext#setState、getState // 记录任务执行进度 // 需要计算收益的数据捞取 ProfitExtractorState imp ProfitState doAction#执行当前状态需要的操作 // 收益计算 ProfitCalculatorState imp ProfitState // 发布计算好的收益数据 ProfitPublisherState imp ProfitState 调用流程 ctx = new ProfitCalculateContext() new ProfitExtractorState().doAction(ctx) // 开始1状态的执行。 new ProfitCalculatorState().doAction(ctx) // 开始3状态的执行。 new ProfitPublisherState().doAction(ctx) // 开始8状态的执行。 优点是什么？ 流程代码去耦合， 状态转换显示化，减少对象间依赖 状态类职责单一，易于扩展新状态 FAQ: 若有需求在ProfitExtractorState类中修改，该类怎么再进行设计？ </description>
    </item>
    
    <item>
      <title>震惊！LocalDateTime.of 比 .plusDays(1) 性能快50倍</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/%E9%9C%87%E6%83%8Alocaldatetime.of-%E6%AF%94-.plusdays1-%E6%80%A7%E8%83%BD%E5%BF%AB50%E5%80%8D/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/%E9%9C%87%E6%83%8Alocaldatetime.of-%E6%AF%94-.plusdays1-%E6%80%A7%E8%83%BD%E5%BF%AB50%E5%80%8D/</guid>
      <description>// 震惊！LocalDateTime.of 比 .plusDays(1) 性能快50倍 public class Demo { public static void main(String[] args) { LocalDateTime now = LocalDateTime.now(); long l = System.currentTimeMillis(); for (int i = 0; i &amp;lt; 100000000; i++) { LocalDateTime localDateTime = now.plusDays(1); } long l1 = System.currentTimeMillis(); System.out.println(&amp;#34;plus time: &amp;#34; + l1 - l); for (int i = 0; i &amp;lt; 100000000; i++) { LocalDateTime localDateTime = LocalDateTime.of(now.toLocalDate(), LocalTime.MAX); } long l2 = System.currentTimeMillis(); System.out.println(&amp;#34;of time: &amp;#34; + l2 - l1); } } // plus time: 1950 // of time: 41 </description>
    </item>
    
    <item>
      <title>重写：文件类加载器</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/golang/golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/golang/golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid>
      <description>Golang文件基础组成 1. 包声明 package main 2. 引入包 import &amp;quot;fmt&amp;quot; 3. 函数 /* 多行注释：这是一个测试函数 */ func main() { // 4.注释: 这是我的第一个简单的程序 fmt.Println(&amp;quot;Hello, World!&amp;quot;) 5. 声明一个变量 [ var identifier type ] var def_str string = &amp;quot;huangruiying&amp;quot; def_str = &amp;quot;huangruiying1&amp;quot; fmt.Println(def_str) var def_int1, def_int2 int = 1, 2 fmt.Println(def_int1, def_int2) } 闭包 函数作为另外一个函数的实参 语言函数方法 type Circle struct { radius float64 } func (c Circle) getArea() float64 { //c.radius 即为 Circle 类型对象中的属性 return 3.</description>
    </item>
    
    <item>
      <title>重写：文件类加载器</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/%E9%87%8D%E5%86%99%E6%96%87%E4%BB%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/%E9%87%8D%E5%86%99%E6%96%87%E4%BB%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</guid>
      <description>常见的类加载器有三种，
当需要以.class文件的形式加载字节码到Jvm时，我们可以定义一个根据字节码文件路径加载类的加载器。
package org.huangry.colorful.project.common.utils.classloader; import lombok.SneakyThrows; import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.InputStream; /** * 自定义字节码文件类加载器 * * @author huangry * Created in 2023/9/6 16:10 */ public class FileSystemClassLoader extends ClassLoader { /** * 字节码文件所属目录 */ private final String bytecodeDirectory; public FileSystemClassLoader(String bytecodeDirectory) { this.bytecodeDirectory = bytecodeDirectory; } @Override protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException { // 查找类是否存在 预定义的目录bytecodeDirectory内 Class&amp;lt;?&amp;gt; clazz = findLoadedClass(name); if (clazz != null) { // 当前类被加载过，直接返回加载好的类 return clazz; } // 双亲委派：获得父类的加载器，委派给父类加载 ClassLoader parent = this.</description>
    </item>
    
    <item>
      <title>注解: NotBlank NotEmpty的使用</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/%E6%B3%A8%E8%A7%A3-notblank-notempty%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/%E6%B3%A8%E8%A7%A3-notblank-notempty%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description> @NotBlank @NotEmpty (javax.validation.constraints.NotBlank) 接口标明 org.springframework.validation.annotation.Validated 注解 要校验的对象标明 javax.validation.Valid 注解 要校验的对象属性标明 javax.validation.constraints.NotBlank 注解 示例： public class Demo{ // 接口操作 @PostMapping(&amp;#34;/demo&amp;#34;) @Validated public Wrapper&amp;lt;Response&amp;gt; demo(@RequestBody @Valid Request request) throws Exception { Response response = method(request); return WrapMapper.&amp;lt;Response&amp;gt;ok().result(response); } public class Request { @ApiModelProperty(&amp;#34;开始日期&amp;#34;) @NotBlank(message = &amp;#34;开始日期不能为空&amp;#34;) private String begDate; @ApiModelProperty(&amp;#34;结束日期&amp;#34;) @NotBlank(message = &amp;#34;结束日期不能为空&amp;#34;) private String endDate; } } </description>
    </item>
    
    <item>
      <title>资源回收：对象销毁前的资源释放</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E5%89%8D%E7%9A%84%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E5%89%8D%E7%9A%84%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/</guid>
      <description>Java对象的销毁是由GC操作，回收前GC会调用目标对象的Object#finalize方法，进行资源释放。
如何确认资源是否有释放呢？
finalize 添加日志 操作系统层面查看 </description>
    </item>
    
    <item>
      <title>Knife4j-接口文档与调试工具</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/knife4j/knife4j-%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 14 Aug 2023 17:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/knife4j/knife4j-%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description> Knife4j Swagger 增强版本 页面友好易操作 有权限认证控制，比swagger安全 支持响应信息JSON折叠 可以导出离线文档 todo https://blog.csdn.net/qing_gee/article/details/122857385 </description>
    </item>
    
    <item>
      <title>SpringBoot-功能实现-配置全局json解析</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E9%85%8D%E7%BD%AE%E5%85%A8%E5%B1%80json%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 31 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E9%85%8D%E7%BD%AE%E5%85%A8%E5%B1%80json%E8%A7%A3%E6%9E%90/</guid>
      <description> </description>
    </item>
    
    <item>
      <title>xxl-job原理剖析 - 客户端执行器是如何被通知的</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/xxljob-%E6%89%B9%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/xxl-job%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%89%A7%E8%A1%8C%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E9%80%9A%E7%9F%A5%E7%9A%84/</link>
      <pubDate>Wed, 19 Jul 2023 16:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/xxljob-%E6%89%B9%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/xxl-job%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%89%A7%E8%A1%8C%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E9%80%9A%E7%9F%A5%E7%9A%84/</guid>
      <description>xxl-job 管理端与客户端采用长连接方式通讯
项目启动时所以jobHandler维护到哪 jobHandlerRepository
注册到管理端的方式 ？初始化了什么 XxlJobExecutor#start.initAdminBizList(adminAddresses[管理端地址], accessToken) AdminBiz adminBiz = (AdminBiz) new XxlRpcReferenceBean(
通过NettyHttp的方式 注册到管理端[调度中心] XxlJobExecutor#start.initRpcProvider(ip, port, appName, accessToken) 1. 创建连接服务端的rpc工厂 xxlRpcProviderFactory = new XxlRpcProviderFactory(); 1. 初始化rpc工厂的相关配置： 通讯方式[NetEnum.NETTY_HTTP]、 Serializer[HESSIAN、HESSIAN1、PROTOSTUFF、KRYO、JACKSON]、 客户端IP、 客户端端口、 TOKEN、 ExecutorServiceRegistry[将客户端ip、客户端与服务端通讯端口 注册到服务端的类，调用该类的start函数]、 ExecutorServiceRegistry#start ExecutorRegistryThread.getInstance().start(param.get(&amp;ldquo;appName&amp;rdquo;), param.get(&amp;ldquo;address&amp;rdquo;)); 注册到管理端具体 执行器组 的参数 serviceRegistryParam:appName[执行器名称],address[当前客户端地址]、 2. 接收管理端通知的服务类 添加到连接工厂中 xxlRpcProviderFactory.addService(ExecutorBiz.class.getName(), null, new ExecutorBizImpl()); 3. 启动连接，通过NettyHttpServer#start 进行连接
接收管理端[调度中心]的调用通知 NettyHttpServerHandler#process
执行结果回调到管理端 TriggerCallbackThread#doCallback 实际使用的是 AdminBiz#callback
客户端如何 执行新任务 XxlJobExecutor.registJobThread 1. 根据jobId + handler 创建任务 2. 通过 JobThread.start 触发任务(启动一个线程) 3.</description>
    </item>
    
    <item>
      <title>规则引擎主流算法之RETE算法</title>
      <link>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8Erete%E7%AE%97%E6%B3%95/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E4%B8%BB%E6%B5%81%E7%AE%97%E6%B3%95%E4%B9%8Brete%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 19 Jul 2023 16:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8Erete%E7%AE%97%E6%B3%95/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E4%B8%BB%E6%B5%81%E7%AE%97%E6%B3%95%E4%B9%8Brete%E7%AE%97%E6%B3%95/</guid>
      <description>Fact（事实）：对象之间及对象属性之间的关系
Rule：条件和结论构成的推理语句，一般表示为if…Then。
条件部分，LHS（left-hand-side）
结论部分，RHS（right-hand-side）
Module（模式）：指不能再继续分割下去的最小的原子条件。
模式就是if语句中的条件，但是条件可能是由几个更小粒度的条件组成，所以模式特指不能再继续被分割的最小原子条件。
RETE 算法主要流程 RETE 算法主要流程可以分为以下步骤：
1 Match：找出符合LHS部分的working memory集合 2 Confilict resolution：选出一个条件被满足的规则 3 Act：执行RHS的内容 4 返回第一步 </description>
    </item>
    
    <item>
      <title>任务调度之时间轮算法</title>
      <link>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 19 Jul 2023 16:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/</guid>
      <description>核心思想
使用场景 定时器、延迟执行、基于时间任务调度
实现思路 时间轮
角色：ptr、bucket、slot、jiffy ptr：指针，随着时间的推移，指针不停地向前移动。 bucket：时间轮由bucket组成，如上图，有12个bucket。每个bucket都挂载了未来要到期的节点（即: 定时任务）。 slot：指相邻两个bucket的时间间隔。 jiffy：slot的单位，1s（1HZ），如上图，总共12个bucket，那么两个相邻的bucket的时间间隔就是一秒。 rotation：表示时间轮要在转动几圈之后才执行定时器，轮数。</description>
    </item>
    
    <item>
      <title>限流算法之计数器</title>
      <link>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/%E8%AE%A1%E6%95%B0%E5%99%A8%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 19 Jul 2023 16:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/%E8%AE%A1%E6%95%B0%E5%99%A8%E7%AE%97%E6%B3%95/</guid>
      <description> 核心流程 通过计数器控制1s内的可访问请求数
弊端：瞬时流量大
设置限流100qps， 1. 那么第一个请求进入时开始计时，并设置计数器n=1， 2. 后续每进入一个请求时，都进行n++， 3. 直至时间到达1s后，将时间和计数器清零。 4. 在0-1s内，当请求总数n=100后，拒绝后续的请求，直至时间到达一秒后重置时间和计数器 突刺现象： 1s内的100个请求集中在前10ms内爆发。在能处理过来的情况下，后990ms都只能拒绝请求。 </description>
    </item>
    
    <item>
      <title>限流算法之令牌桶</title>
      <link>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/%E4%BB%A4%E7%89%8C%E6%A1%B6%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Wed, 19 Jul 2023 16:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/%E4%BB%A4%E7%89%8C%E6%A1%B6%E6%A8%A1%E5%9E%8B/</guid>
      <description> 令牌桶核心流程 通过token系统拿token 携带有效token即认定为合法请求 无效token或无token则拒绝 细节剖析 令牌桶模型是由以下几个角色组成的： 令牌 - 相当于门票，允许服务请求处理的标识 桶 - 令牌的载体，相当于售票处 令牌生产者 - 匀速生成令牌并放入桶内的程序 是开发者控制流量的手段，开发者可以控制每10ms生成一个令牌。 当令牌数量达到上限时，就丢弃令牌。 </description>
    </item>
    
    <item>
      <title>限流算法之漏桶</title>
      <link>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/%E6%BC%8F%E6%A1%B6%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Wed, 19 Jul 2023 16:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/%E6%BC%8F%E6%A1%B6%E6%A8%A1%E5%9E%8B/</guid>
      <description> 漏桶核心流程 通过代码控制请求，通过平均时间段，均匀散布一秒内的请求。
弊端：保证不了每个请求之间正好是100ms，可能会是120ms .. 这样会降低一秒内的请求数。
1.假设1s限流100 【每秒请求量为100，preRequest=1/100】 2.那么漏桶模型则是将100个请求散布在这1s内【请求1处理完成时刻记做limiter.last,请求2进入时刻与last对比，没有达到preRequest,则让当前线程sleep至间隔时间刚好等于preRequest即可】 3.理论上每个请求10ms【正常情况下】 4.但是会出现此种情况！ 1.请求1执行完成15ms后请求2才到达，此时立即执行请求2，请求3在请求2执行完成5ms后到达， 理论上要sleep 5ms后才能执行请求3，但是如此的话总耗时就为15+10=25ms，理想状态应该是20ms才可以， 所以引入【将之前所有多余的耗时累计起来，在后续做抵消使用，该值可正可负， 正：前面等待时间过长超过preRequest，负：前面等待时间不足preRequest】 </description>
    </item>
    
    <item>
      <title>Calcite 校验SQL</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/calcite/calcite%E6%A0%A1%E9%AA%8Csql/</link>
      <pubDate>Tue, 18 Jul 2023 20:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/calcite/calcite%E6%A0%A1%E9%AA%8Csql/</guid>
      <description></description>
    </item>
    
    <item>
      <title>DynamicTP线程池介绍</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/dynamictp/dynamictp%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Tue, 18 Jul 2023 20:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/dynamictp/dynamictp%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%8B%E7%BB%8D/</guid>
      <description>美团动态线程池 解决了什么问题? 动态调整线程池大小：Dynamic-Tp可以根据当前负载情况动态调整线程池的大小，从而保证程序的高效性和稳定性。 任务调度和优先级管理：Dynamic-Tp支持任务调度和优先级管理，可以根据任务类型和重要程度自动调整任务的执行优先级。 任务队列管理：Dynamic-Tp支持任务队列管理，可以根据任务类型、重要程度和执行时间等因素对任务队列进行优化。 异常处理和容错能力：Dynamic-Tp具有良好的异常处理和容错能力，可以在任务执行过程中自动处理异常，并且保证程序的稳定性。 配置灵活：Dynamic-Tp提供了灵活的配置选项，可以根据实际需求进行调整。 https://dynamictp.cn/guide/middleware/middleware.html</description>
    </item>
    
    <item>
      <title>DynamicTP在SpringBoot中的使用</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/dynamictp/dynamictp%E5%9C%A8springboot%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 18 Jul 2023 20:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/dynamictp/dynamictp%E5%9C%A8springboot%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description> 添加依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dynamic-tp&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 创建 import org.springframework.context.annotation.Bean; class DynamicTPConfigureDemo { @Bean public ThreadPoolExecutor threadPoolExecutor() { DynamicTpThreadPoolExecutor executor = new DynamicTpThreadPoolExecutor(); executor.setCorePoolSize(10); executor.setMaximumPoolSize(50); executor.setQueueCapacity(100); executor.setThreadNamePrefix(&amp;#34;dynamic-tp-thread-&amp;#34;); executor.initialize(); return executor; } } 使用 public class DynamicTPUseDemo { @Autowired private ThreadPoolExecutor threadPoolExecutor; public void use() { threadPoolExecutor.execute(new Runnable() { @Overridepublic void run() { // 任务执行逻辑 } }); } } </description>
    </item>
    
    <item>
      <title>MyBatisPlus-部分源码</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mybatis-plus/mybatisplus-%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81/</link>
      <pubDate>Tue, 18 Jul 2023 20:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mybatis-plus/mybatisplus-%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81/</guid>
      <description>MybatisMapperProxy
识别语句类型 MybatisMapperMethod#execute public Object execute(SqlSessi
获取真实SQL MappedStatement#selectList ms.getBoundSql(parameter)
executor </description>
    </item>
    
    <item>
      <title>MyBatisPlus-动态多数据源</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mybatis-plus/mybatisplus-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/</link>
      <pubDate>Tue, 18 Jul 2023 20:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mybatis-plus/mybatisplus-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/</guid>
      <description></description>
    </item>
    
    <item>
      <title>MybatisPlus-基础操作</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mybatis-plus/mybatisplus-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 18 Jul 2023 20:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mybatis-plus/mybatisplus-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</guid>
      <description> 使用 lambda 实现自定义查询字段 QueryWrapper wrapper = new QueryWrapper&amp;lt;&amp;gt;(); wrapper.select(&amp;quot; DISTINCT receipt_company_name &amp;ldquo;).lambda()&amp;hellip;
使用判空 summaryWrapper.eq(Objects.nonNull(query.getBillType()), MarkingCheckDetail::getBillType, query.getBillType())
this.lambdaQuery() this.lambdaQuery().eq(FinancialReportInfoDetail::getReportId, 1000000001L).list()
IPage page = this.lambdaQuery().eq(FinancialReportInfoDetail::getRuleType, ruleType.getCode()).page(new Page&amp;lt;&amp;gt;(pageNo, 2000));
QueryWrapper及LambdaQueryWrapper </description>
    </item>
    
    <item>
      <title>Nacos-常用参数解释</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/nacos/nacos-%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A/</link>
      <pubDate>Tue, 18 Jul 2023 20:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/nacos/nacos-%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A/</guid>
      <description>spring.cloud.nacos.discovery.namespace=TEST05 # 指定在Nacos环境中进行服务发现时的流量预热时间 spring.cloud.nacos.discovery.flow-preheat-time=300 # nacos服务端地址 spring.cloud.nacos.discovery.server-addr=10.10.11.27\:8848,10.10.11.36\:8848,10.10.11.37\:8848 spring.cloud.nacos.discovery.namespace-backup=TEST # 将特定的服务名称映射到模拟主机，指定提供服务的机器。 spring.cloud.nacos.discovery.mock.host.map={\n\t&amp;#34;activityws&amp;#34;\:&amp;#34;172.17.195.126\:23100&amp;#34;,\n\t&amp;#34;messagews&amp;#34;\:&amp;#34;172.17.195.126\:23020&amp;#34;,\n&amp;#34;kafka-service&amp;#34;\:&amp;#34;127.0.0.1\:8081&amp;#34;\n} spring.cloud.nacos.discovery.profile=test spring.cloud.nacos.discovery.self-health-check-enabled=true spring.cloud.nacos.discovery.username=service spring.cloud.nacos.discovery.mock.switch=false spring.cloud.nacos.discovery.password=aadc1935-6cc2-496e-895b-4ceb1055c3fe </description>
    </item>
    
    <item>
      <title>Nacos-在元数据中增加注册时间</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/nacos/nacos-%E5%9C%A8%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%A2%9E%E5%8A%A0%E6%B3%A8%E5%86%8C%E6%97%B6%E9%97%B4/</link>
      <pubDate>Tue, 18 Jul 2023 20:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/nacos/nacos-%E5%9C%A8%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%A2%9E%E5%8A%A0%E6%B3%A8%E5%86%8C%E6%97%B6%E9%97%B4/</guid>
      <description> /** * 在服务注册至nacos客户端时，在服务详情中增加相应的元数据，增加服务注册时间 */ package czb.settle.ledger.core.config; import com.alibaba.cloud.nacos.ConditionalOnNacosDiscoveryEnabled; import com.alibaba.cloud.nacos.NacosDiscoveryProperties; import com.alibaba.cloud.nacos.discovery.NacosDiscoveryAutoConfiguration; import org.springframework.boot.autoconfigure.AutoConfigureBefore; import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean; import org.springframework.cloud.client.CommonsClientAutoConfiguration; import org.springframework.cloud.client.discovery.simple.SimpleDiscoveryClientAutoConfiguration; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.text.SimpleDateFormat; import java.util.Date; @Configuration @ConditionalOnNacosDiscoveryEnabled @AutoConfigureBefore({NacosDiscoveryAutoConfiguration.class,SimpleDiscoveryClientAutoConfiguration.class, CommonsClientAutoConfiguration.class}) public class NacosDiscoveryClientAutoConfiguration { @Bean @ConditionalOnMissingBean public NacosDiscoveryProperties nacosProperties() { NacosDiscoveryProperties properties = new NacosDiscoveryProperties(); // 记录注册时间到NacosDiscoveryProperties properties.getMetadata().put(&amp;#34;startup.time&amp;#34;, new SimpleDateFormat(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;).format(new Date())); return properties; } } </description>
    </item>
    
    <item>
      <title>Velocity-简介与基础使用</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/velocity/velocity-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 18 Jul 2023 20:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/velocity/velocity-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</guid>
      <description>Velocity，是一个基于java的模板引擎，可以用于动态生成java代码，并编译&amp;amp;加载，也可以动态渲染页面，渲染邮件内容等。
Maven依赖 &amp;lt;!-- velocity --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.velocity&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;velocity&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.7&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.velocity&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;velocity-tools&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 模板示例 hello.vm // 设置name的默认属性值为huangry #set($name = &amp;#34;huangry&amp;#34;) public class $className { public void printInfo() { System.out.println(&amp;#34;Hello, $name!&amp;#34;); } } 案例：通过模板生成Java代码，并加载到Jvm执行。 public class GenJavaCodeDemo { private static final String classPath = &amp;#34;/Users/nenglianjituan/open_source/TestClass.java&amp;#34;; public static void main(String[] args) throws Exception { ClassLoader classLoader = null; // 创建Velocity引擎：在Java代码中创建一个VelocityEngine对象，并使用它根据指定的模板，渲染出Java代码 VelocityEngine ve = new VelocityEngine(); ve.setProperty(Velocity.FILE_RESOURCE_LOADER_PATH, &amp;#34;/Users/nenglianjituan/huangry/huangry-wiki/src/main/resources&amp;#34;); ve.init(); // 创建模板文件：创建一个Velocity模板文件，其中包含Java代码的模板。模板文件通常以.vm为扩展名 // 加载模板文件：使用VelocityEngine对象加载模板文件。 Template template = ve.</description>
    </item>
    
    <item>
      <title>动态SQL解析器解决方案 - Calcite</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/calcite/calcite%E9%87%8D%E5%86%99sql/</link>
      <pubDate>Tue, 18 Jul 2023 20:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/calcite/calcite%E9%87%8D%E5%86%99sql/</guid>
      <description>Calcite Apache顶级项目，主要功能包含SQL 解析、SQL 校验、查询优化、SQL 生成器、数据连接。
解析过程
Maven依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.calcite&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;calcite-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.34.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 操作代码 public class CalciteDemo { // 创建解析器 private static final SqlParser.Config mysqlConfig = SqlParser.config() .withLex(Lex.MYSQL) .withCaseSensitive(false) .withCaseSensitive(false)//大小写敏感 .withQuoting(Quoting.BACK_TICK) .withQuotedCasing(Casing.TO_LOWER) .withUnquotedCasing(Casing.TO_LOWER) .withConformance(SqlConformanceEnum.MYSQL_5); private static final SqlParser.Config oracleConfig = SqlParser.config() .withLex(Lex.ORACLE) .withCaseSensitive(false)//大小写敏感 .withQuoting(Quoting.BACK_TICK) .withQuotedCasing(Casing.TO_LOWER) .withUnquotedCasing(Casing.TO_LOWER) .withConformance(SqlConformanceEnum.ORACLE_12); private static final SqlParser.Config sqlserverConfig = SqlParser.config() .withLex(Lex.SQL_SERVER) .withCaseSensitive(false)//大小写敏感 .withQuoting(Quoting.BACK_TICK) .withQuotedCasing(Casing.TO_LOWER) .withUnquotedCasing(Casing.TO_LOWER) .withConformance(SqlConformanceEnum.SQL_SERVER_2008); // 构建树 SqlNode sqlTree = SqlParser.create(sqlAtomic.get(), mysqlConfig).parseQuery(); /** * 创建自定义查询条件 * * @param where age &amp;gt; 12 and name !</description>
    </item>
    
    <item>
      <title>服务指标与SLA服务保障</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%8C%87%E6%A0%87/sla%E6%9C%8D%E5%8A%A1%E4%BF%9D%E9%9A%9C/</link>
      <pubDate>Mon, 17 Jul 2023 10:54:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%8C%87%E6%A0%87/sla%E6%9C%8D%E5%8A%A1%E4%BF%9D%E9%9A%9C/</guid>
      <description> SLA(service level agreement) 即服务品质协议。 一般是客户与服务提供商间达成的服务质量协议。包含正常运行时间、交付时间、响应时间和解决时间等指标。SLA包含SLI和SLO。
SLI(service level indicator) 即服务等级关键量化指标。 指标 含义 适用场景 计算公式 &amp;mdash;&amp;ndash; &amp;mdash;&amp;ndash; &amp;mdash;&amp;mdash; &amp;mdash;&amp;mdash; HA: 高可用（High Availability） 服务可用情况 通用，通常所说的99.9% 99.99% 计划可用时间/(计划可用时间+故障时间)*100 ; 请求成功/(请求成功+请求失败)*100 # 分布式系统 通常使用此计算公式简化复杂情况; 99% 故障时间不超过432分钟/月 7.2小时/月 ; 99.9% 故障时间不超过43.2分钟/月 ; 99.99% 故障时间不超过4.32分钟/月 QPS: 每秒并发量(Queries Per Second) 查询返回能力（每秒） 适合并发查询服务 QPS = 请求成功总数/单位时间 RPS:每秒处理量(Response Per Second) 操作返回能力（每秒） 适合接口多任务服务 TPS: 每秒吞吐量(Transactions Per Second) 事务处理能力（每秒） 适合异步多任务服务 TPS = 任务总数/单位时间 RT: 响应时间(Response Time) 请求响应时间（每秒） 适合所有接口服务 通常关注90%请求算数平均 RT = 单位时间总请求响应时间和/总请求数 并发量 接口用户请求数（每秒） 并不准确与QPS相互估算 并发量 ～= QPS * RT MTBF: 平均出错间隔（Mean Time Between Fail） MTBF = MTTF + MTTR 服务稳定性衡量,越大越好 MTTR: 平均修复时间(Mean Time To Repair) 服务稳定性衡量,越小越好 MTTF: 平均无间隔(Mean time to Failure) 服务稳定性衡量,越大越好 </description>
    </item>
    
    <item>
      <title>GuavaCache的使用</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/guavacache/0x02.guavacache%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/guavacache/0x02.guavacache%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>创建一个超时时间为5分钟的缓存
private final Cache&amp;lt;String, BigDecimal&amp;gt; rateCache = CacheBuilder.newBuilder().expireAfterAccess(5, TimeUnit.MINUTES).build(); 缓存使用
try { // 查询数据 return rateCache.get(mchId, () -&amp;gt; selectFromDB(xx)); } catch (Exception e) { log.warn(&amp;#34;通过缓存获取数据异常！&amp;#34;, e); return selectFromDB(xx); } </description>
    </item>
    
    <item>
      <title>ShardingSphere使用文档</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/shardingsphere/0x01.shardingsphere%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/shardingsphere/0x01.shardingsphere%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</guid>
      <description>1. 依赖pom配置 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;sharding-jdbc-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.1.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.postgresql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;postgresql&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;42.2.8&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 2. sharding 配置示例 ### 数据源配置 # 定义三个数据源，名字为ds0 ds1的是分库的同一业务库，名字为one的是独立的未分库的业务库 spring.shardingsphere.datasource.names=ds0,ds1,one # 指定单库one数据源配置 spring.shardingsphere.datasource.one.driver-class-name=org.postgresql.Driver spring.shardingsphere.datasource.one.jdbc-url=jdbc:postgresql://10.61.11.179:8000/newlink?characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;prepareThreshold=0&amp;amp;binaryTransfer=false&amp;amp;currentSchema=czb_payment spring.shardingsphere.datasource.one.type=com.zaxxer.hikari.HikariDataSource spring.shardingsphere.datasource.one.username=dws_shen_rw spring.shardingsphere.datasource.one.password=0EAuucV6^KI # 指定分库ds0 ds1数据源配置 spring.shardingsphere.datasource.ds0.driver-class-name=com.mysql.cj.jdbc.Driver spring.shardingsphere.datasource.ds0.jdbc-url=jdbc:mysql://10.10.11.122:3306/czb_finance_settle?characterEncoding=UTF-8&amp;amp;zeroDateTimeBehavior=convertToNull&amp;amp;allowMultiQueries=true&amp;amp;serverTimezone=Asia/Shanghai spring.shardingsphere.datasource.ds0.type=com.zaxxer.hikari.HikariDataSource spring.shardingsphere.datasource.ds0.username=test_dev02 spring.shardingsphere.datasource.ds0.password=AFG1cL0S2Dert spring.shardingsphere.datasource.ds1.driver-class-name=com.mysql.cj.jdbc.Driver spring.shardingsphere.datasource.ds1.jdbc-url=jdbc:mysql://10.10.11.122:3306/czb_finance_settle?characterEncoding=UTF-8&amp;amp;zeroDateTimeBehavior=convertToNull&amp;amp;allowMultiQueries=true&amp;amp;serverTimezone=Asia/Shanghai spring.shardingsphere.datasource.ds1.type=com.zaxxer.hikari.HikariDataSource spring.shardingsphere.datasource.ds1.username=test_dev02 spring.shardingsphere.datasource.ds1.password=AFG1cL0S2Dert ### 配置分库分表规则及单表规则 # 分库配置(策略 inline、standard、complex、hint、none) spring.shardingsphere.sharding.tables.test_table.database-strategy.standard.sharding-column=tenant_id # 分库键 spring.shardingsphere.sharding.tables.test_table.database-strategy.standard.precise-algorithm-class-name=czb.settle.ledger.core.config.application.CustomizeShardingAlgorithm # 分库规则：精准分片算法 # 分表配置(策略 inline、standard、complex、hint) # inline 简单策略表达式，不支持特殊范围 spring.shardingsphere.sharding.tables.test_table.table-strategy.inline.sharding-column=user_id # 分表键、分片列 spring.shardingsphere.sharding.tables.test_table.table-strategy.inline.algorithm-expression=test_table_$-&amp;gt;{user_id % 100 + 1} # 分片(表)规则表达式，映射到物理表 # standard 标准分片策略 spring.</description>
    </item>
    
    <item>
      <title>SpringBoot-功能实现-Logback日志级别动态切换</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-logback%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-logback%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2/</guid>
      <description>配置化：通过 logging.level 切换日志输出级别(与动态切换相比，这个只能在启动前配置，启动过后无法变更) 默认：logging.level.root=info 指定包：logging.level.org.huangry.colorful.mds.controller.web=debug 指定类：logging.level.org.huangry.colorful.mds.controller.web.AbcController=debug
手动切换：请求接口切换日志级别 @RestController @Slf4j class DynamicModifyLoggerPrintLevel { /** * * @param pkg 指定需要设置的日志记录器的名称 * @param level 将通过接口传入的级别转换为LogLevel后进行设置 */ @GetMapping(&amp;#34;modifyLoggerLevel&amp;#34;) public void modifyLoggerLevel(@RequestParam(&amp;#34;pkg&amp;#34;) String pkg, @RequestParam(&amp;#34;level&amp;#34;) String level) { LoggingSystem system = LoggingSystem.get(LoggingSystem.class.getClassLoader()); system.setLogLevel(pkg, resolveLogLevel(level)); } private LogLevel resolveLogLevel(String level) { String trimmedLevel = level.trim(); return LogLevel.valueOf(trimmedLevel.toUpperCase(Locale.ENGLISH)); } @GetMapping(&amp;#34;testLog&amp;#34;) public void testLog() { log.info(&amp;#34;info&amp;#34;); log.debug(&amp;#34;debug&amp;#34;); if (log.isDebugEnabled()) { log.debug(&amp;#34;isDebugEnabled&amp;#34;); } } } 动态切换：通过配置变更切换日志级别 global.logger.level = {&amp;#39;xxx.</description>
    </item>
    
    <item>
      <title>SpringBoot-功能实现-过滤器</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E8%BF%87%E6%BB%A4%E5%99%A8/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E8%BF%87%E6%BB%A4%E5%99%A8/</guid>
      <description>本文旨在SpringBoot中如何创建一个过滤器。 直接实现Filter接口+@Component /** * 定义过滤器 */ @Component public class TimeFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(&amp;#34;过滤器初始化&amp;#34;); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException { long start = new Date().getTime(); filterChain.doFilter(request, response); System.out.println(&amp;#34;执行耗时：&amp;#34; + (new Date().getTime() - start)); } @Override public void destroy() { System.out.println(&amp;#34;过滤器销毁&amp;#34;); } } @Bean+@Configuration（第三方Filter）；非@Component标注的filter类 @Configuration public class WebConfig extends WebMvcConfigurerAdapter { @Autowired TimeInterceptor timeInterceptor; @Bean public FilterRegistrationBean charsetFilter() { FilterRegistrationBean registrationBean = new FilterRegistrationBean(); // 注册过滤器到Spring registrationBean.</description>
    </item>
    
    <item>
      <title>SpringBoot-功能实现-跨域</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E8%B7%A8%E5%9F%9F/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E8%B7%A8%E5%9F%9F/</guid>
      <description>🧍
import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.HttpMethod; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.reactive.CorsWebFilter; import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource; import java.time.Duration; /** * * 跨域配置 * */ @Configuration public class SystemCorsConfiguration { @Bean public CorsWebFilter corsWebFilter() { CorsConfiguration corsConfig = new CorsConfiguration(); corsConfig.setAllowCredentials(true); corsConfig.addAllowedHeader(CorsConfiguration.ALL); corsConfig.addAllowedMethod(HttpMethod.GET); corsConfig.addAllowedMethod(HttpMethod.POST); corsConfig.addAllowedMethod(HttpMethod.PUT); corsConfig.addAllowedMethod(HttpMethod.DELETE); corsConfig.setMaxAge(Duration.ofMinutes(30)); corsConfig.addAllowedOrigin(CorsConfiguration.ALL); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&amp;#34;/**&amp;#34;, corsConfig); return new CorsWebFilter(source); } } </description>
    </item>
    
    <item>
      <title>SpringBoot-功能实现-拦截器</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E5%88%87%E9%9D%A2/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E5%88%87%E9%9D%A2/</guid>
      <description>本文旨在SpringBoot中如何创建一个切面。</description>
    </item>
    
    <item>
      <title>SpringBoot-功能实现-拦截器</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E6%8B%A6%E6%88%AA%E5%99%A8/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E6%8B%A6%E6%88%AA%E5%99%A8/</guid>
      <description>本文旨在SpringBoot中如何创建一个拦截器。
/** * 定义拦截器 * * @author huangry * Created in 2023/7/21 10:18 */ @Component @Slf4j public class SelfDefineInterceptor extends HandlerInterceptorAdapter { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { log.info(&amp;#34;beg SelfDefineInterceptor&amp;#34;); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { log.info(&amp;#34;end SelfDefineInterceptor&amp;#34;); } } @Configuration public class SelfDefineWebMvcConfigurerAdapter extends WebMvcConfigurationSupport {// WebMvcConfigurer /** * 注册拦截器 */ @Autowired private SelfDefineInterceptor SelfDefineInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { // 注册拦截器,自定义不同拦截器拦截不同的地址 registry.</description>
    </item>
    
    <item>
      <title>SpringBoot-功能实现-日志操作</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%E5%88%B0%E6%96%87%E4%BB%B6%E4%B8%8E%E7%BA%A7%E5%88%AB%E5%88%87%E6%8D%A2/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%E5%88%B0%E6%96%87%E4%BB%B6%E4%B8%8E%E7%BA%A7%E5%88%AB%E5%88%87%E6%8D%A2/</guid>
      <description>自定义日志文件输出：手动生成日志 &amp;amp; 打入指定日志文件 &amp;lt;!-- 定义日志对象及信息 --&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;!-- 定义「指定」日志文件配置 --&amp;gt; &amp;lt;appender name=&amp;#34;httpConsumer&amp;#34; class=&amp;#34;ch.qos.logback.core.rolling.RollingFileAppender&amp;#34;&amp;gt; &amp;lt;file&amp;gt;${LOG_FILE}/consumer.log&amp;lt;/file&amp;gt; &amp;lt;encoder&amp;gt; &amp;lt;pattern&amp;gt;%msg%n&amp;lt;/pattern&amp;gt; &amp;lt;immediateFlush&amp;gt;true&amp;lt;/immediateFlush&amp;gt; &amp;lt;charset&amp;gt;UTF-8&amp;lt;/charset&amp;gt; &amp;lt;/encoder&amp;gt; &amp;lt;rollingPolicy class=&amp;#34;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&amp;#34;&amp;gt; &amp;lt;fileNamePattern&amp;gt;${LOG_FILE}/consumer-%d{yyyy-MM-dd-HH}-%i.log&amp;lt;/fileNamePattern&amp;gt; &amp;lt;maxFileSize&amp;gt;300MB&amp;lt;/maxFileSize&amp;gt; &amp;lt;maxHistory&amp;gt;240&amp;lt;/maxHistory&amp;gt; &amp;lt;CleanHistoryOnStart&amp;gt;true&amp;lt;/CleanHistoryOnStart&amp;gt; &amp;lt;totalSizeCap&amp;gt;60GB&amp;lt;/totalSizeCap&amp;gt; &amp;lt;/rollingPolicy&amp;gt; &amp;lt;/appender&amp;gt; &amp;lt;!-- 定义日志对象及信息 --&amp;gt; &amp;lt;appender name=&amp;#34;asyncHttpConsumer&amp;#34; class=&amp;#34;ch.qos.logback.classic.AsyncAppender&amp;#34;&amp;gt; &amp;lt;appender-ref ref=&amp;#34;httpConsumer&amp;#34;/&amp;gt; &amp;lt;queueSize&amp;gt;1024&amp;lt;/queueSize&amp;gt; &amp;lt;neverBlock&amp;gt;true&amp;lt;/neverBlock&amp;gt; &amp;lt;/appender&amp;gt; &amp;lt;!-- 创建日志对象，java代码里面通过name获取日志句柄 --&amp;gt; &amp;lt;logger name=&amp;#34;http_consumer_log&amp;#34; additivity=&amp;#34;false&amp;#34;&amp;gt; &amp;lt;appender-ref ref=&amp;#34;asyncHttpConsumer&amp;#34;/&amp;gt; &amp;lt;/logger&amp;gt; &amp;lt;/configuration&amp;gt; /** * 输出自定义日志到指定日志文件 &amp;lt;br/&amp;gt; * 例如：http_consumer_log */ public class Loggers { public static void main(String[] args) { // 获取日志对象，并向其输出日志信息 Loggers.getHttpConsumerLogger().info(JSONObject.toJSONString(logMap)); } /** * 我方调用外部服务的日志 */ private static final Logger HTTP_CONSUMER_LOGGER = LoggerFactory.</description>
    </item>
    
    <item>
      <title>SpringBoot-功能实现-日志操作-MDC的使用</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E6%97%A5%E5%BF%97-mdc%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E6%97%A5%E5%BF%97-mdc%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>MDC：Mapped Diagnostic Context，可以粗略的理解成是一个 线程安全的 存放诊断日志的 容器
代码示例 /** * MDC快速入门示例 * * 写REQ_ID到日志中 * */ public class SimpleMDC { private static final Logger logger = LoggerFactory.getLogger(SimpleMDC.class); // REQ_ID 需要在logback.xml 内定义好 public static final String REQ_ID = &amp;#34;REQ_ID&amp;#34;; public static final String TENANT = &amp;#34;Tenant&amp;#34;; public static void main(String[] args) { MDC.put(REQ_ID, UUID.randomUUID().toString()); MDC.put(TENANT, &amp;#34;存放租户ID&amp;#34;); logger.info(&amp;#34;开始调用服务A，进行业务处理&amp;#34;); logger.info(&amp;#34;业务处理完毕，可以释放空间了，避免内存泄露&amp;#34;); MDC.remove(REQ_ID); logger.info(&amp;#34;REQ_ID 还有吗？{}&amp;#34;, MDC.get(REQ_ID) != null); } } logback.xml 示例 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34; ?&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;appender name=&amp;#34;CONSOLE&amp;#34; class=&amp;#34;ch.</description>
    </item>
    
    <item>
      <title>SpringBoot-功能实现-指定数据源执行SQL</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E6%8C%87%E5%AE%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E6%89%A7%E8%A1%8Csql/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E6%8C%87%E5%AE%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E6%89%A7%E8%A1%8Csql/</guid>
      <description></description>
    </item>
    
    <item>
      <title>SpringBoot-检测方法事物</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/0x01.%E6%A3%80%E6%B5%8B%E5%BD%93%E5%89%8D%E6%96%B9%E6%B3%95%E4%BA%8B%E7%89%A9%E6%83%85%E5%86%B5/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/0x01.%E6%A3%80%E6%B5%8B%E5%BD%93%E5%89%8D%E6%96%B9%E6%B3%95%E4%BA%8B%E7%89%A9%E6%83%85%E5%86%B5/</guid>
      <description> 检测当前是否存在事物 方法一:可以通过 TransactionSynchronizationManager#isActualTransactionActive 进行事物情况的判断。
public class TransactionTest{ @Test @Transactional public void test1(){ // 存在 @Transactional 注解时，返回 true; boolear isOpen = TransactionSynchronizationManager.isActualTransactionActive(); } @Test public void test2() { // 删除 @Transactional 注解时，返回 false; boolear isOpen = TransactionSynchronizationManager.isActualTransactionActive(); } } 方法二:可以通过 TransactionSynchronizationRegistry 检测是否存在事物。
import javax.transaction.Status; import javax.transaction.TransactionManager; import javax.transaction.TransactionSynchronizationRegistry; public class TransactionExample { private TransactionManager transactionManager; private TransactionSynchronizationRegistry synchronizationRegistry; public boolean isTransactionActive() { int transactionStatus = synchronizationRegistry.getTransactionStatus(); return transactionStatus == Status.STATUS_ACTIVE; } } 打印当前事物标识信息 </description>
    </item>
    
    <item>
      <title>SpringBoot-接口学习-Converter</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0-convertert%E4%BD%93%E7%B3%BB/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0-convertert%E4%BD%93%E7%B3%BB/</guid>
      <description>Converter的作用是什么 Converter 是 Spring 框架中的一个通用接口，用于在不同的类型之间进行转换。它定义了一个 convert 方法，用于将一个对象从一个类型转换为另一个类型 Converter核心方法介绍 Converter的作用范围是什么 如何自定义一个Converter // 一对一转换示例;比如String转Boolean、String转Integer // org.springframework.core.convert.converter.Converter&amp;lt;S, T&amp;gt; import org.springframework.context.annotation.Configuration; @Configuration public class ConvertConfiguration() { @Bean public Converter&amp;lt;String, LocalDate&amp;gt; localDateConverter() { return new Converter&amp;lt;String, LocalDate&amp;gt;() { @Override public LocalDate convert(String source) { return LocalDate.parse(source, DateTimeFormatter.ofPattern(&amp;#34;yyyy-MM-dd&amp;#34;)); } }; } } // 一转多示例;比如String转Enum // org.springframework.core.convert.converter.ConverterFactory&amp;lt;S, R&amp;gt; public class StringToEnumConverterFactory implements ConverterFactory&amp;lt;String, Enum&amp;gt; { @Override public &amp;lt;T extends Enum&amp;gt; Converter&amp;lt;String, T&amp;gt; getConverter(Class&amp;lt;T&amp;gt; targetType) { return new StringToEnum(ConversionUtils.</description>
    </item>
    
    <item>
      <title>SpringBoot-接口学习-Converter、TypeConverter、HttpMessageConverter使用场景与比较</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0-convertertypeconverterhttpmessageconverter%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E6%AF%94%E8%BE%83/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0-convertertypeconverterhttpmessageconverter%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E6%AF%94%E8%BE%83/</guid>
      <description>Converter 的使用场景
TypeConverter 的使用场景主要用于在 Spring 框架中的 Bean 中进行数据类型转换
转换时会调用 convertIfNecessary &amp;ndash; 它提供了一种方便的方式来将属性值从字符串表示转换为 Java 类型，并在整个 Spring 框架中得到广泛应用。TypeConverter 接口定义了一个 convertIfNecessary 方法，用于将字符串值转换为指定的 Java 类型。HttpMessageConverter 主要用于在 HTTP 请求和响应中进行数据转换。它提供了一种方便的方式来将 Java 对象转换为 HTTP 请求或响应中的格式，例如 JSON、XML、HTML 等
HttpMessageConverter 的使用场景主要用于在 HTTP 请求和响应中进行数据转换。（自身为服务，被请求 和 通过http、rpc请求外部服务） 接受请求时; HTTP 请求转换成对象 响应请求时; 对象转换成 HTTP，（转json xml html &amp;hellip;） 实际使用代码;
Feign 注册：保证注册到 SpringDecoder#messageConverters 中 public class HttpMessageConverterConfiguration{ // FeignClientsConfiguration // feign 初始化HttpMessageConverter到SpringDecoder位置 @Bean @ConditionalOnMissingBean public Decoder feignDecoder() { return new OptionalDecoder( new ResponseEntityDecoder(new SpringDecoder(this.messageConverters))); } // http } 使用：SpringDecoder#decode(extractor.</description>
    </item>
    
    <item>
      <title>SpringBoot-接口学习-HandlerMethodArgumentResolver</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0-handlermethodargumentresolver/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0-handlermethodargumentresolver/</guid>
      <description>HandlerMethodArgumentResolver
是SpringBoot的一个扩展接口，用于在http请求到控制层(controller)之前，根据需求灵活指定具体参数的值，并配合Spring框架，将新的参数作为入参，请求到控制层的入口方法。 该接口中一共存在两个方法
1. supportsParameter: 作用是匹配规则，当满足本方法的规则时，会执行resolveArgument。 2. resolveArgument: 作用是具体解析/操作参数。 @startuml &amp;#39;https://plantuml.com/sequence-diagram legend center Http请求调用HandlerMethodArgumentResolver流程 end legend autonumber 前端 -&amp;gt; RequestMappingHandlerAdapter#invokeHandlerMethod : 发送请求 RequestMappingHandlerAdapter#invokeHandlerMethod -&amp;gt; RequestMappingHandlerAdapter#createInvocableHandlerMethod: 初始化方法处理器 RequestMappingHandlerAdapter#createInvocableHandlerMethod -&amp;gt; RequestMappingHandlerAdapter#createInvocableHandlerMethod: 调用 setHandlerMethodArgumentResolvers 初始化参数解析器(自定义的也在其中) 团油支付 --&amp;gt; 团油订单: 支付单success 团油订单 --&amp;gt; &amp;#34;骑士卡|团油前端&amp;#34;: 订单success &amp;#34;骑士卡|团油前端&amp;#34; -&amp;gt; &amp;#34;骑士卡|团油前端&amp;#34;: 在收银台选择支付方式 &amp;#34;骑士卡|团油前端&amp;#34; -&amp;gt; 团油支付: 携带支付方式，获取支付参数(含支付串获取地址的) group 间连通道 团油支付 -&amp;gt; 团油支付: 间连通道：根据开关(灰度、白名单...)选择通道，生成scheme 团油支付 --&amp;gt; &amp;#34;骑士卡|团油前端&amp;#34;: 间连支付：返回scheme + 间连标识 &amp;#34;骑士卡|团油前端&amp;#34; -&amp;gt; 微信or支付宝: 跳转微信or支付宝 微信or支付宝 -&amp;gt; 团油支付: 获取支付串 团油支付 --&amp;gt; 微信or支付宝: 依据支付串，唤起小程序收银台 end group 直连通道 团油支付 -&amp;gt; 团油支付: 直连通道：根据收款主体，路由支付服务类 团油支付 --&amp;gt; &amp;#34;骑士卡|团油前端&amp;#34;: 直连支付：返回唤起app支付的h5参数 &amp;#34;骑士卡|团油前端&amp;#34; -&amp;gt; 微信or支付宝: 跳转微信or支付宝 end 微信or支付宝 -&amp;gt; 微信or支付宝: 用户支付成功 微信or支付宝 --&amp;gt; 团油支付: 支付结果回告 @enduml SpringBoot是如何使用HandlerMethodArgumentResolver进行解析的呢?</description>
    </item>
    
    <item>
      <title>SpringBoot-接口学习-HttpMessageConverter</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0-httpmessageconvertert%E4%BD%93%E7%B3%BB/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0-httpmessageconvertert%E4%BD%93%E7%B3%BB/</guid>
      <description>HttpMessageConverter的作用是什么 将请求的HTTP协议转换为Java对象 将响应的Java对象转换为HTTP协议 rpc HttpMessageConverter核心方法介绍 -- 是否可将请求的HTTP协议读为对象 canRead -- 是否可将响应的对象写到HTTP协议 canWrite -- 将请求的Http协议读成对象 read -- 将响应的对象写入Http协议 write -- 获取当前转换器支持的所有Media类型 getSupportedMediaTypes HttpMessageConverter的作用范围是什么 对于Http请求，作为服务对外暴露接口时：
使用@RequestBody注解时，HTTP转Java对象
使用@ResponseBody注解时，Java对象转HTTP
对于Rpc请求，使用Feign请求注册中心其他服务时：
将请求参数转换成Http参数
将响应的Http数据，通过SpringDecoder调用HttpMessageConverter,转换成接口定义的对象。
Http和Rpc场景，维护的位置在哪？ rpc: FeignClientsConfiguration#messageConverters http: RestTemplate#messageConverters // 发送http请求前 RequestCallback#doWithRequest 中处理，使用 // 处理http响应
// 接收http请求前 HttpRequestHandler#handleRequest // 响应数据
如何自定义一个HttpMessageConverter package czb.settle.ledger.core.config.application; import org.springframework.http.HttpHeaders; import org.springframework.http.HttpInputMessage; import org.springframework.http.HttpOutputMessage; import org.springframework.http.MediaType; import org.springframework.http.converter.AbstractHttpMessageConverter; import org.springframework.http.converter.HttpMessageNotReadableException; import org.springframework.http.converter.HttpMessageNotWritableException; import org.springframework.lang.Nullable; import org.springframework.util.Assert; import org.springframework.util.StreamUtils; import java.io.IOException; import java.</description>
    </item>
    
    <item>
      <title>SpringBoot-接口学习-InitializingBean</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0-initializingbean/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0-initializingbean/</guid>
      <description>在设置了所有「当前对象」属性后调用
public class A implements InitializingBean{
}</description>
    </item>
    
    <item>
      <title>SpringBoot框架全局配置</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE-webmvcconfigurationsupport/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE-webmvcconfigurationsupport/</guid>
      <description>package org.huangry.colorful.project.common.config.system; import lombok.extern.slf4j.Slf4j; import org.huangry.colorful.project.common.config.interceptor.TestInterceptor; import org.springframework.boot.SpringBootConfiguration; import org.springframework.util.ResourceUtils; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport; import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter; import javax.annotation.PostConstruct; /** * mvc配置类，可获取ServletContext、ApplicationContext * WebMvcAutoConfiguration会失效 * &amp;lt;p&amp;gt; * {@link WebMvcConfigurationSupport} 是 {@linkplain WebMvcConfigurerAdapter} 的替代品，会使其自动失效 */ @SpringBootConfiguration @Slf4j public class SystemWebMvcConfigurationSupport extends WebMvcConfigurationSupport /*implements WebMvcConfigurer*/ { private static final String tag = &amp;#34;SystemWebMvcConfigurationSupport&amp;#34;; @PostConstruct public void postConstruct() { log.info(&amp;#34;【初始化 SystemWebMvcConfigurationSupport】&amp;#34;); } /** * 静态资源位置 * addResourceHandler(&amp;#34;/**&amp;#34;).addResourceLocations(ResourceUtils.CLASSPATH_URL_PREFIX+&amp;#34;/static&amp;#34;) * 表示 请求/500.html 就可以访问到/static/500.html 文件。 * 若后续有映射覆盖了之前映射，则最后一个映射生效。 * curl http://localhost:8081/500.</description>
    </item>
    
    <item>
      <title>优秀缓存框架必备的几个功能</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/guavacache/0x01.%E4%BC%98%E7%A7%80%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E5%BF%85%E5%A4%87%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/guavacache/0x01.%E4%BC%98%E7%A7%80%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E5%BF%85%E5%A4%87%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8A%9F%E8%83%BD/</guid>
      <description>缓存的三种模型：旁路型、穿透型、异步型 旁路型：即先去缓存中尝试查询获取数据，如果获取不到则会从数据库中进行查询并加入到缓存中； 穿透型：查询不到缓存时，自动取数据源的数据，并放入缓存。缓存框架封装的逻辑，不用人工再实现。
多种缓存过期策略 1. 基于创建时间过期 2. 基于访问时间过期
多种缓存载体 jvm、堆外内存、内存型数据库、缓存文件
支持缓存容量上限设置 针对高效的jvm缓存，内存有限，所以要支持控制住缓存占用的空间。 可以通过条数控制 可以通过容量控制
支持自定义缓存淘汰算法 即然内存有限，想要最优使用缓存，那必然要将实际业务场景与缓存淘汰策略结合，故需支持灵活淘汰算法。 可以手动指定缓存淘汰算法 可以动态调整缓存淘汰算法
支持缓存不存在时,自动更新缓存 （穿透型缓存、回源查询） 当查询缓存，发现结果为空(不存在或过期),可以通过预先写好的逻辑，执行查询数据源，获取结果并进行缓存。</description>
    </item>
    
    <item>
      <title>0x01.开源数据可视化系统-Davinci</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/davinci-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/0x01.%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F-davinci/</link>
      <pubDate>Wed, 12 Jul 2023 10:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/davinci-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/0x01.%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F-davinci/</guid>
      <description>开源地址 https://github.com/edp963/davinci https://gitee.com/mirrors/Davinci?_from=gitee_search
二次开发 https://dumplingbao.github.io/2020/04/03/davinci-dev-egl/</description>
    </item>
    
    <item>
      <title>@BeanMapping用法</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mapstruct/mapstruct.0x05.@beanmapping%E7%94%A8%E6%B3%95/</link>
      <pubDate>Mon, 10 Jul 2023 18:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mapstruct/mapstruct.0x05.@beanmapping%E7%94%A8%E6%B3%95/</guid>
      <description> 禁用同名属性自动转换 @BeanMapping(ignoreByDefault = true)
代码示例 </description>
    </item>
    
    <item>
      <title>@BeforeMapping、@AfterMapping用法</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mapstruct/mapstruct.0x04.@beforeaftermapping%E7%94%A8%E6%B3%95/</link>
      <pubDate>Mon, 10 Jul 2023 18:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mapstruct/mapstruct.0x04.@beforeaftermapping%E7%94%A8%E6%B3%95/</guid>
      <description> 代码示例 @Mapper public interface BusinessConvertMapper { BusinessConvertMapper INSTANCE = Mappers.getMapper(BusinessConvertMapper.class); @Mappings(value = { @Mapping(target = &amp;#34;column1&amp;#34;, ignore = true), @Mapping(target = &amp;#34;column2&amp;#34;, ignore = true)} ) ToModel convert(FromModel from); @BeforeMapping default void preProcess() { System.out.println(&amp;#34;执行前置处理......&amp;#34;); } /** * 在调用转换方法后触发 * @param to 转换方法的响应类型 */ @AfterMapping default void postProcess(@MappingTarget ToModel to) { // ToModel 的CouponName字段长度大于128时，做截断处理 if (StringUtils.isNotBlank(to.getCouponName()) &amp;amp;&amp;amp; bill.getCouponName().length() &amp;gt; 128) { String substring = bill.getCouponName().substring(0, 128); bill.setCouponName(substring); } } } </description>
    </item>
    
    <item>
      <title>@BeforeMapping用法</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mapstruct/mapstruct.0x03.@mappings%E7%94%A8%E6%B3%95/</link>
      <pubDate>Mon, 10 Jul 2023 18:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mapstruct/mapstruct.0x03.@mappings%E7%94%A8%E6%B3%95/</guid>
      <description>代码示例 /** * from */ public class BillFileModel { private String one; private int two; private Three three; } /** * to */ public class BillDBModel { private String one; private int two; private String three; } Mapping 及target ignore 属性用法 // 第一步：使用 org.mapstruct.Mapper 注解，标记为映射接口。 @Mapper public interface BillConvertMapper { BillConvertMapper INSTANCE = Mappers.getMapper( BillConvertMapper.class ); // 第二步：定义映射方法，明确入参的「源」对象bean，和返回的「目标」对象dto @Mapping(source = &amp;#34;one&amp;#34;, target = &amp;#34;one&amp;#34;) // 忽略不需要映射的字段 @Mappings(value = { @Mapping(target = &amp;#34;one&amp;#34;, ignore = true), @Mapping(target = &amp;#34;two&amp;#34;, ignore = true), @Mapping(target = &amp;#34;three&amp;#34;, ignore = true)} ) BillDBModel convertToBillFrom(BillFileModel model); } expression 属性用法 import czb.</description>
    </item>
    
    <item>
      <title>@MapperConfig用法</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mapstruct/mapstruct.0x07.@mapperconfig%E7%94%A8%E6%B3%95/</link>
      <pubDate>Mon, 10 Jul 2023 18:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mapstruct/mapstruct.0x07.@mapperconfig%E7%94%A8%E6%B3%95/</guid>
      <description>设置&amp;quot;未映射的目标策略&amp;quot;的配置 @MapperConfig(unmappedTargetPolicy = ReportingPolicy.IGNORE) interface MappingConfig { }
指定配置到mapper @Mapper(config = MappingConfig.class) public interface PersonMapper { }</description>
    </item>
    
    <item>
      <title>@Mapper用法</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mapstruct/mapstruct.0x06.@mapper%E7%94%A8%E6%B3%95/</link>
      <pubDate>Mon, 10 Jul 2023 18:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mapstruct/mapstruct.0x06.@mapper%E7%94%A8%E6%B3%95/</guid>
      <description>设置&amp;quot;未映射的目标策略&amp;quot; @Mapper(unmappedTargetPolicy = ReportingPolicy.IGNORE) public interface MyMapper {}
实例创建、使用方式：componentModel 以spring组件方式，使用 @Mapper(componentModel = &amp;ldquo;spring&amp;rdquo;)
实例创建、使用方式：手动创建单例 public interface TaskExecRecordConverter { TaskExecRecordConverter INSTANCE = Mappers.getMapper(TaskExecRecordConverter.class); }
导入包 @Mapper(imports = {MappingExpression.class})</description>
    </item>
    
    <item>
      <title>Mapstruct用法</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mapstruct/mapstruct.0x02.%E7%94%A8%E6%B3%95/</link>
      <pubDate>Mon, 10 Jul 2023 18:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mapstruct/mapstruct.0x02.%E7%94%A8%E6%B3%95/</guid>
      <description> Maven 依赖 &amp;lt;lombok.version&amp;gt;1.18.30&amp;lt;/lombok.version&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mapstruct&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mapstruct&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.5.5.Final&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${lombok.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.8.1&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;source&amp;gt;1.8&amp;lt;/source&amp;gt; &amp;lt;target&amp;gt;1.8&amp;lt;/target&amp;gt; &amp;lt;annotationProcessorPaths&amp;gt; &amp;lt;!-- lombok 顺序要在 mapstruct 前面--&amp;gt; &amp;lt;path&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${lombok.version}&amp;lt;/version&amp;gt; &amp;lt;/path&amp;gt; &amp;lt;path&amp;gt; &amp;lt;groupId&amp;gt;org.mapstruct&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mapstruct-processor&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${mapstruct.version}&amp;lt;/version&amp;gt; &amp;lt;/path&amp;gt; &amp;lt;/annotationProcessorPaths&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; </description>
    </item>
    
    <item>
      <title>Lombok-常用注解</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/jaxb/jaxb-%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 10 Jul 2023 17:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/jaxb/jaxb-%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description> 是一款java解析xml的插件 使用泛型 // 使用泛型时，要把泛型可能的类型维护到该注解内 @XmlSeeAlso({QsPayInnerReq.class,QsPayOuterReq.class,QsPayQueryReq.class}) @Data @XmlRootElement(name = &amp;#34;BankData&amp;#34;) public class BaseQSReq&amp;lt;T&amp;gt; { @XmlElement(name = &amp;#34;Sign&amp;#34;) private Sign sign; @XmlElement(name = &amp;#34;opReq&amp;#34;) private OpReq opReq; @XmlElement(name = &amp;#34;ReqParam&amp;#34;) private T reqParam; @XmlTransient public Sign getSign() { return sign; } @XmlTransient public OpReq getOpReq() { return opReq; } @XmlTransient public T getReqParam() { return reqParam; } } // 使用泛型后，在标签内生成 xsi:type=&amp;#34;qsPayQueryReq&amp;#34; // 如何从JAXB泛型中删除xsi：type，xmlns：xs和xmlns：xs </description>
    </item>
    
    <item>
      <title>Lombok-常用注解</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/lombok/lombok-%E5%9F%BA%E7%A1%80%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Mon, 10 Jul 2023 17:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/lombok/lombok-%E5%9F%BA%E7%A1%80%E6%B3%A8%E8%A7%A3/</guid>
      <description>@SneakyThrows 将编译时异常包装为运行时异常RuntimeException 代码见 Lombok.sneakyThrow(t);</description>
    </item>
    
    <item>
      <title>Mapstruct介绍</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mapstruct/mapstruct.0x01.%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 10 Jul 2023 17:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mapstruct/mapstruct.0x01.%E4%BB%8B%E7%BB%8D/</guid>
      <description>官网解释 what? 这是什么
代码生成器，基于配置方法的约定，简化不同 Java Bean 间映射与转换。 映射关系以普通代码维护，因此快速、类型安全且易于理解。 why? 出现的原因
多层应用程序通常需要在不同的对象模型（例如实体和 DTO）之间进行映射。编写这样的映射代码是一项繁琐且容易出错的任务。MapStruct旨在通过尽可能自动化来简化这项工作。 与其他映射框架相比，MapStruct在编译时生成bean映射，这确保了高性能，允许快速的开发人员反馈和彻底的错误检查。 How?
MapStruct是一个注释处理器，它插入Java编译器，可以在命令行构建（Maven，Gradle等）以及您首选的IDE中使用。 MapStruct使用合理的默认值，但在配置或实现特殊行为时会让你不碍事。 了解更多&amp;hellip;</description>
    </item>
    
    <item>
      <title>MyBatis-功能实现-SQL拦截器</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mybatis/mybatis-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-sql%E6%8B%A6%E6%88%AA%E5%99%A8/</link>
      <pubDate>Mon, 10 Jul 2023 17:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/mybatis/mybatis-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-sql%E6%8B%A6%E6%88%AA%E5%99%A8/</guid>
      <description>Mybatis 执行过程 MyBatis SQL拦截相关注解 /** * 拦截点 */ @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface Intercepts { /** * 定义拦截点 * 只有符合拦截点的条件才会进入到拦截器 */ Signature[] value(); } /** * 拦截条件 */ @Documented @Retention(RetentionPolicy.RUNTIME) @Target({}) public @interface Signature { /** * 定义要拦截的类,范围：Executor、ParameterHandler、StatementHandler、ResultSetHandler * * Executor：拦截执行器的方法 * 执行查询数据：BaseExecutor#query.queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql) * ParameterHandler：拦截参数的处理 * ResultHandler：拦截结果集的处理 * StatementHandler：拦截Sql语法构建的处理 */ Class&amp;lt;?&amp;gt; type(); /** * 定义拦截 {@link this#type()} 中具体哪些方法 */ String method(); /** * 当 {@link this#method()} 在 {@link this#type()} 中存在重名方法时， * 通过参数指定，明确拦截具体哪个方法 * */ Class&amp;lt;?</description>
    </item>
    
    <item>
      <title>使用Micrometer收集数据介绍</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/micrometer/%E4%BD%BF%E7%94%A8micrometer%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 10 Jul 2023 17:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/micrometer/%E4%BD%BF%E7%94%A8micrometer%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE%E4%BB%8B%E7%BB%8D/</guid>
      <description>1.收集什么数据 主要用户采集服务及服务器相关指标
e.g. 服务器cpu空闲率、使用率、内存、硬盘等相关数据 服务jvm相关指标、活跃线程数、接口流量等
2.使用什么工具收集 可以使用IBM的micrometer进行指标收集 Micrometer会捞取相关指标信息 灌入influxdb内 https://www.cnblogs.com/cjsblog/p/11556029.html https://www.ibm.com/developerworks/cn/java/j-using-micrometer-to-record-java-metric/index.html https://micrometer.io/docs/ref/cache
3.工具的使用 maven依赖包
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.micrometer&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;micrometer-spring-legacy&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.micrometer&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;micrometer-registry-influx&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; ##4.工具所需要的依赖(数据库 influxdb..)
启动influxdb nohup influxd -config /usr/local/etc/influxdb.conf &amp;gt;out.log 2&amp;gt;&amp;amp;1 &amp;amp; 连接influxdb influx -host 127.0.0.1 -port 8086 ##5.捞到的数据有哪些
disk_free http_server_requests jvm_buffer_count jvm_buffer_memory_used jvm_buffer_total_capacity jvm_classes_loaded jvm_classes_unloaded jvm_gc_live_data_size jvm_gc_max_data_size jvm_gc_memory_allocated jvm_gc_memory_promoted jvm_gc_pause jvm_memory_committed jvm_memory_max jvm_memory_used jvm_threads_daemon jvm_threads_live jvm_threads_peak jvm_threads_states #日志信息 log4j2_events process_cpu_usage process_files_max process_files_open process_start_time process_uptime system_cpu_count system_cpu_usage system_load_average_1m tomcat_global_error tomcat_global_received tomcat_global_request tomcat_global_request_max tomcat_global_sent tomcat_sessions_active_current tomcat_sessions_active_max tomcat_sessions_alive_max tomcat_sessions_created tomcat_sessions_expired tomcat_sessions_rejected tomcat_threads_busy tomcat_threads_config_max tomcat_threads_current 数据是如何收集的？以JVM为例</description>
    </item>
    
    <item>
      <title>对账系统概述</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F/0.%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Sun, 25 Jun 2023 16:16:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F/0.%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</guid>
      <description> 总体来说，对账系统可抽象为以下流程 其中，获取我方数据可扩展为 获取外部需对账数据可扩展为 对账结果处理 针对不同业务需求，会对对账结果汇总、轧差、差异处理、开票、导出等相关操作
数据对比流程 通过代码，捞取DB中固定数据，指定对账双方的对账关系和对账字段，进行比对 缺点：代码需要大量定制，不通用，其他业务线接入对账的成本较高。 塑造对账模板（SQL + 别名 + 条件）、对账配置。 自定义数据模型；通过配置SQL的方式，定义多个数据模板，并有数据标记，用于区分不同业务角度的数据(业务支付单、三方通道支付单等)。 自定义对账配置；通过选择数据模型，生成对账配置，供对账程序使用。 高性能对账程序；开发一套通用的对账程序，读取对账配置并对账。 根据配置指定执行频次、数据捞取范围等数据模型需要的参数，并拿到数据模型进行数据的获取与对比。 使用外部能力，如数据灌入Hive，利用HiveSQL，将数据导出为 核对成功、存疑数据 表。 核对成功：通过SQL，对本端的单边账，结果写入表 存疑数据：对于两端数据非完全一致的，标记数据存疑(可能为 ) 通过SQL，对本端的单边账 通过SQL，对渠道/通道端的单边账 使用 SQL union 将 1 2 结果合并，并写入表 二次存疑数据处理：针对单边对账时无法区分的差异，进行双边核对 数据汇总： DP 平台 Sprak 任务进行处理 对比结果输出 -- </description>
    </item>
    
    <item>
      <title>实时对账思路与实践</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E6%97%B6%E5%AF%B9%E8%B4%A6%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Sun, 25 Jun 2023 16:16:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E6%97%B6%E5%AF%B9%E8%B4%A6%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%AE%9E%E8%B7%B5/</guid>
      <description></description>
    </item>
    
    <item>
      <title>使用Hive进行高效对账</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8hive%E8%BF%9B%E8%A1%8C%E9%AB%98%E6%95%88%E5%AF%B9%E8%B4%A6/</link>
      <pubDate>Sun, 25 Jun 2023 16:16:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8hive%E8%BF%9B%E8%A1%8C%E9%AB%98%E6%95%88%E5%AF%B9%E8%B4%A6/</guid>
      <description>依赖Hive达到离线高效对账的目的，主要是使用其超大数据集计算能力。
首先将要对账的数据灌入Hive，然后利用HiveSQL，把数据导出为「 核对成功、存疑数据 」表。
核对成功：通过SQL，利用内连查询，将一致数据筛选处来，结果写入表 insert overwrite table dp.check_success select result.对比成功后要落库的字段 from ( select 对比成功后要落库的字段 from dp.我方数据 our inner join dp.三方数据 third on our.关联字段 = third.关联字段 -- 数据对比条件 and our.trader_amount = third.trader_amount and our.channel_code = third.channel_code where -- 数据对比范围 our.is_check = 0 and third.is_check = 0 and our.bill_date = &amp;#39;${DP_1_DAYS_AGO_Ymd}&amp;#39; and third.bill_date = &amp;#39;${DP_1_DAYS_AGO_Ymd}&amp;#39; and our.is_filter = 0 ) result 存疑筛选: 对于两端数据非完全一致的，标记数据存疑(数据并非完全一致的，需要再进行存疑处理)，并筛选到表中 (insert overwrite table dp.check_error) 建立我方数据单边账SQL：SELECT 对账字段 FROM (我方数据) our LEFT JOIN (三方数据) third ON (对账条件) WHERE third.</description>
    </item>
    
    <item>
      <title>使用自建SQL模板对账</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%BB%BAsql%E6%A8%A1%E6%9D%BF%E5%AF%B9%E8%B4%A6/</link>
      <pubDate>Sun, 25 Jun 2023 16:16:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%BB%BAsql%E6%A8%A1%E6%9D%BF%E5%AF%B9%E8%B4%A6/</guid>
      <description> 一般对账逻辑是什么样子的？ 通过写离线任务，将需要对账的两份数据，捞取到内存或刷入对账表中，然后进行逐笔对账。
这种方式对账存在什么问题？ 效率性能影响：在没有从库、离线库情况下，离线任务数据捞取对业务会有影响，控制任务捞取的话，对对账效率会有影响。 代码需要定制：每个新业务都需要写一套代码，定义捞取业务数据的字段，以及对比的字段。 如何能够以最低成本对账 可以写一套通用的SQL数据模板，用SQL + 别名 + 条件的方式，将双方数据进行标准化，捞取对账的业务数据，然后进行比较。
分页排序对比问题怎么办？ 是啊，咋办？
直接使用业务库的弊端 业务影响：直接查主库对账的话，必定影响业务。一般会查从库或离线库。 性能影响：一般业务库使用MySQL，性能相对一些NoSQL较差。 同库限制：要是设计的模板表中，没有数据源标记的话，那么第一个限制就是只能在同一个库内进行对比。 使用高性能数据库的接入成本(低成本) 搭建实时数据同步通道，可将表1:1的洗入数仓等位置。 配置数据模板、对账配置。(无论使用哪种库都需要构建配置，忽略) 可以将多张表洗为一张宽表，方便对比。 当前对账方式解决了什么问题 多库多表问题：要对账的数据散落在同库内多张不同种类的业务数据表，或不同库的多张表内。通过数据工具直接洗成宽表。 屏蔽业务复杂度：避免了用代码逻辑对比、汇总数据，开发人员可无需关注其他业务逻辑。 不同业务的对账快速接入：因为屏蔽了业务差异，将对账抽象成了工具，所以可快速支撑不同业务的对账需求。 对账流程应该包含哪些内容与步骤 塑造数据模板（SQL + 别名 + 条件）、对账配置
自定义数据模型；通过配置SQL的方式，定义多个数据模板，并有数据标记，用于区分不同业务角度的数据(业务支付单、三方通道支付单等)。 自定义对账配置；通过选择数据模型，生成对账配置，明确了哪两个数据模型进行对比，供对账程序使用。 对账结果输出；初期可以简单直给，后期可根据业务情况定义多套输出模板，维护到对账配置中。 高性能对账程序；开发一套通用的对账程序，读取对账配置并对账。 根据配置指定执行频次、数据捞取范围等数据模型需要的参数，并拿到数据模型进行数据的获取与对比。 </description>
    </item>
    
    <item>
      <title>【基础】多数据源建设与动态路由(数据源的原理与动态数据源使用)</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/1.%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E4%B8%8E%E5%88%86%E7%89%87/%E5%9F%BA%E7%A1%80%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%BB%BA%E8%AE%BE%E4%B8%8E%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 25 Jun 2023 10:54:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/1.%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E4%B8%8E%E5%88%86%E7%89%87/%E5%9F%BA%E7%A1%80%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%BB%BA%E8%AE%BE%E4%B8%8E%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BD%BF%E7%94%A8/</guid>
      <description>先了解数据源的定义 数据源，就是一个获取数据库连接的工厂类，是java官方的定义，所有数据库连接池有遵循该标准
package javax.sql; import java.sql.Connection; import java.sql.SQLException; import java.sql.Wrapper; public interface DataSource extends CommonDataSource, Wrapper { Connection getConnection() throws SQLException; Connection getConnection(String username, String password) throws SQLException; } 数据源的创建 我们在配置文件中，维护好数据库地址、驱动类等信息，并在代码中创建DataSource对象，读取到配置文件中的配置信息。 自创建DataSource对象
@Configuration @Slf4j public class DataSourceConfig { @Bean(name = &amp;#34;testDruidDataSource&amp;#34;) public DataSource dataSource() { DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(dataSourceParam.getDriverClassName()); DRIVER_CLASSNAME = dataSourceParam.getDriverClassName(); ds.setUrl(dataSourceParam.getUrl()); ds.setUsername(dataSourceParam.getUsername()); ds.setPassword(dataSourceParam.getPassword()); ds.setInitialSize(dataSourceParam.getInitialSize()); ds.setMinIdle(dataSourceParam.getMinIdle()); ds.setMaxActive(dataSourceParam.getMaxActive()); ds.setMinEvictableIdleTimeMillis(dataSourceParam.getMinEvictableIdleTimeMillis()); ds.setValidationQuery(dataSourceParam.getValidationQuery()); ds.setTestWhileIdle(dataSourceParam.isTestWhileIdle()); ds.setTestOnBorrow(dataSourceParam.isTestOnBorrow()); ds.setTestOnReturn(dataSourceParam.isTestOnReturn()); ds.setPoolPreparedStatements(dataSourceParam.isPoolPreparedStatements()); ds.setMaxPoolPreparedStatementPerConnectionSize(dataSourceParam.getMaxPoolPreparedStatementPerConnectionSize()); ds.setMaxWait(60000); log.info(&amp;#34;【&amp;#34; + this.</description>
    </item>
    
    <item>
      <title>0x01.支付系统概述</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/0x01.%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Sun, 25 Jun 2023 10:54:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/0x01.%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</guid>
      <description> 国际清算委员会定义: 所有涉及到资金转移的行为,都可视作支付行为,清算和结算属于支付过程中的特定环节。
清算发生在结算前,清算是为了提高结算标准化水平和效率。
支付系统：完成付款人向收款人转移货币债权的过程，包括交易过程、清算过程和结算过程。
支付(交易动作)：付款人通过金融机构提供的能力，向收款人交换支付工具(买受人付款给出卖人)。
清分(数据整理)：将全部交易数据，进行按照各个成员之间的往来方向、金额、手续费等进行分类、整理。（清算的数据准备阶段）
清算(汇总入账)：根据清分的结果进行汇总、轧差产生清算报表，填制清算的会计分录(根据轧差的净额)，并据此登记账务。
结算(资金划拨)：根据清分以及清算的数据，实现资金划拨过程。
对账(参与角色对账)： 一般在支付活动中，同银行内账户资金往来直接结算便可，而涉及不同银行之间账户资金往来的，则需先清算再结算。
名词-头寸 头寸：其实就是款项的意思，指的是银行当前所有可以运用的资金的总和，主要包括在央行的超额准备金、存放同业清算款项净额、银行存款以及现金等部分。 作为专业术语的头寸，也称为“头衬”，是一种市场约定，承诺买卖合约的最初部位，买进合约者是多头，处于盼涨部位；卖出合约者为空头，处于盼跌部位。 收多付少，叫做“多头寸”；收少付多，叫做“缺头寸”； 结算收付差额，叫做“轧头寸”；借款弥补差额，叫做“拆头寸”；想方设法调进款项，叫做“调头寸”； 暂时未用款项大于需用量，叫做“头寸松”；资金需求量大于闲置量，叫做“头寸紧”。 10个“袁大头”摞起来的高度，恰好是一寸，“头寸”这个词便是由此而来的
支付通道维度 维度 描述 示例 支付方式 不同场景的支付类型 信用卡支付、储蓄卡支付、第三方支付、网银支付 支付通道 提供支付服务的公司 微信、支付宝、京东、建行、易宝、汇付 支付产品 支付通道可用的产品 小程序支付、扫码、信用付、网银支付、app支付、银行卡、被扫 支付方式： 是指用户在支付过程中选择的具体支付类型，例如信用卡支付、储蓄卡支付、第三方支付、网银支付等。 每一种支付方式都有其特定的使用场景和特点，例如信用卡支付通常需要输入信用卡信息进行支付，网银支付则需要登录银行网站或使用银行App进行支付。
支付通道： 支付产品： 将已有的支付通道打包成可归类的商户产品。例如支付宝、微信支付等第三方支付的支付产品。 这些支付产品可以提供一站式的支付解决方案，包括支付方式、支付渠道、对账、结算等功能，同时也提供了丰富的支付场景和接口，方便用户进行集成和定制化开发。
案例1，用户想用扫码支付，可以使用微信、支付宝、京东的扫码支付付款给商户。 案例2，用户习惯用京东支付，可以使用京东任意产品付款给商户。 案例3，用户通过c端App(团油)，选择支付宝支付，可以使用易宝/汇付这种间连通道，走小程序支付。
场景todo 场景：小满在平安好车主渠道通过团油签约的油站，购买油品，并使用微信支付通道付款给好车主。 角色： 微信：收单机构(支付通道) 平安好车主：渠道 油站：售油商户 小满：个人用户 团油：平台 对账： 渠道对账：团油支付单与好车主支付单对账 商户对账：团油订单与油站订单对账 支付通道对账：团油支付单与微信账单对账 资金流： 用户 -&amp;gt; 好车主在微信的商户 好车主 -&amp;gt; 团油 + 好车主 团油 -&amp;gt; 油站 + 团油 </description>
    </item>
    
    <item>
      <title>0x02.支付系统结构</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/0x02.%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 25 Jun 2023 10:54:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/0x02.%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</guid>
      <description>DDD 宏观域
支付系统流程 用户，使用手机，选产品去支付，跳转到收银台，选择支付方式，创建支付单，串风控、营销(各种优惠、红包)、 支付网关域 作用：支付系统流量出入口 网关核心子域：(串 流控、身份鉴别、加解密算法执行、证书维护、请求路由 的流程) 身份鉴别子域： API路由子域 支付域 作用：支撑支付整体流程、支付方式展示、状态流转。调用营销、通道等。类似支付前台。 支付核心(串 风控、营销优惠、创建支付单、选择支付通道 的流程) - 调用支付风控 - 调用支付营销，计算优惠 - 支付单创建 - 状态推进 - 接收通道、渠道回告 - 回告业务系统 引导路由：支付方式展示。主要针对收银台编排，不同用户、机型等参数展示不同支付方式 交易路由：通过染色的流量，识别业务、服务，并路由到指定收款、付款域，进行收单、打款相关操作。 支付风控： 支付营销：渠道优惠、优惠 支付账户： 商户后台：业务方进件信息维护。 支付产品：包装通道产品。信用付、小程序支付、银行卡、信用卡支付等 支付通道域 收款子域：B2C场景下，商户提供为三方用户提供服务，收取相应费用。 付款子域：B2C场景下，商户给用户打款(奖励、赔付等) 支付(通道)路由子域：根据费率、稳定性等因素，选择最优通道，降低成本和提高效率。 规则引擎配置系统 支付通道管理系统 通道网关子域：屏蔽通道差异，与通道交互。对接收款、打款通道。 请求签名 数据加解密 通道适配器 基础支持域 证书平台：支撑支付网关、通道网关 算法平台：支撑支付网关与业务方、通道网关与支付通道交互时的加解密需求 流控平台：支撑整个系统流量控制，服务入口、通道调用等控制 支付交易路由
支付风控
支付营销 作用：支付通道活动、业务渠道活动、自有满减活动支撑 - 支付券 - 积分奖励 - 通道活动 - 业务活动
支付通道（路由） 作用：根据用户选择的支付方式，结合费率、QOS等因素，选择最优支付通道 增量工作：新支付通道对接
支付通道管理
支付通道QPS
支付通道QOS
收款商户管理
日志管理</description>
    </item>
    
    <item>
      <title>0x03.支付出海关注点</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/0x03.%E6%94%AF%E4%BB%98%E5%87%BA%E6%B5%B7%E5%85%B3%E6%B3%A8%E7%82%B9/</link>
      <pubDate>Sun, 25 Jun 2023 10:54:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/0x03.%E6%94%AF%E4%BB%98%E5%87%BA%E6%B5%B7%E5%85%B3%E6%B3%A8%E7%82%B9/</guid>
      <description>关注点 产品DTC出海模式（直面消费者：产品，价格，宣传，渠道） 支付： 1。钱怎么收，如何兼容包并多国不同的支付习惯，针对各地区支付习惯，选择支付产品与收单机构 可以根据合作业务，先针对业务发生国家进行调研。 2。成本问题，如何才能做到费率低（本土C端支付，以及B端跨境结算成本高） 3。合规、欺诈问题， 收款合规：需要明确各个国家支付监管要求。在能收钱的前提下保证「能提钱」。 结算合规：明确合法的结算方式&amp;hellip; 数据合规：保证不泄漏用户数据，安全性方面要有考虑，在数据传输和落地要有四要素等加密。 欺诈问题：跨国线上交易，欺诈手段则更加多样 钓鱼、爬虫、数据窃取、账户盗用要有相关措施。 4。
收钱：可先采用微信、支付宝海外付</description>
    </item>
    
    <item>
      <title>流动计算架构之就近路由</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/1.%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97/%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%B0%B1%E8%BF%91%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Sun, 25 Jun 2023 10:54:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/1.%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97/%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%B0%B1%E8%BF%91%E8%B7%AF%E7%94%B1/</guid>
      <description>定义好每个机房的注册中心实例列表。 通过当前服务所属机房，优先动态选择当前机房负载低的注册中心。若是负载均高，那再请求其他机房的注册中心。
就近路由 是在多机房环境下，尽可能降低服务调用过程的耗时，及服务资源的合理分配。 （当前服务 根据规则{距离、注册中心负载}进行智能的访问注册中心 和「服务」） 假设存在三个机房 A B C，订单服务调用支付服务 在理想状态下(所有服务负载一致)，A机房订单服务调用A机房的支付服务，资源损耗最低，网络延迟最低。 当同机房支付服务负载过高时，可以智能选择注册中心内的最优可用服务。 当同机房支付服务负载降低后，可再智能切回同机房的下游服务调用。 达到在下游服务负载不同、机房不同时，选择最优的服务进行请求。 那么，就会涉及到几个点：
获取某服务所有机房的实例负载 自定义服务调用权重及白名单 成本计算：主要针对资源调用成本 实现流动计算架构之就近路由的操作流程
继承 AbstractLoadBalancerRule ，重写 com.netflix.loadbalancer.IRule#choose， </description>
    </item>
    
    <item>
      <title>流动计算架构之泳道环境</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/1.%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97/%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84%E4%B9%8B%E6%B3%B3%E9%81%93%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Sun, 25 Jun 2023 10:54:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/1.%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97/%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84%E4%B9%8B%E6%B3%B3%E9%81%93%E7%8E%AF%E5%A2%83/</guid>
      <description> 流量全链路识别 流量从入口应用进来之后， 如果被识别成灰度流量，则在每次RPC调用时，会优先通过泳道标签(染色的流量)，识别并选择目标服务(染色的节点)。 如果目标服务没有灰度环境，则会降级到目标服务的基线环境。 动态数据源识别。 节点染色 服务注册时，向Nacos注册泳道标签 该标签可以在服务启动参数里配置，Nacos原生支持 流量染色 Web、App、H5等客户端的请求头埋入 (主动携带) 在网关层通过白名单、二级域名、灰度负载均衡、等方式注入 (被动规则) 对于MQ的流量染色 由于user-property是key-value的结构，可以在user-property中存储灰度标识 生成灰度消息的三个方式： ①如果请求在入口被识别成灰度请求，则该消息会被标记成灰度消息。 ②如果节点本身属于灰度节点，且开启了流量染色，则该消息会被标记为灰度消息。 ③入口处请求没有被识别成灰度流量，但消息本身的 payload 属于灰度流量，则该消息也会被标记成灰度消息。 改造范围 对于测试环境，要考虑资源统一管理、动态扩展、用户申请、自动回收及基础的console功能。 对于生成环境，支持发布时的节点染色和客户端的流量染色即可。 若存在就近路由，可基于就近路由，在选择机房机器的逻辑基础上，依赖泳道标签，减少流量可选的真实有效服务范围。 </description>
    </item>
    
    <item>
      <title>企业BI平台预研课题</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E4%BC%81%E4%B8%9Abi%E5%B9%B3%E5%8F%B0%E9%A2%84%E7%A0%94%E8%AF%BE%E9%A2%98/</link>
      <pubDate>Sun, 25 Jun 2023 10:54:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E4%BC%81%E4%B8%9Abi%E5%B9%B3%E5%8F%B0%E9%A2%84%E7%A0%94%E8%AF%BE%E9%A2%98/</guid>
      <description>目标：服务于部门内部财务、业财、B端、企业应用等体系的趋势分析&amp;amp;经营分析&amp;amp;财经管报等展示
一期功能 项目搭建 Echarts集成 数据展示 二期功能 图表容器 前端自定义创建(Grafana) </description>
    </item>
    
    <item>
      <title>浅谈系统拆分思路</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E6%B5%85%E8%B0%88%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Sun, 25 Jun 2023 10:54:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E6%B5%85%E8%B0%88%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86%E6%80%9D%E8%B7%AF/</guid>
      <description>可以通过流量类型拆分：假设当前服务80%流量是用作基础信息查询，可以统计下接口，单独拉起一个提供查询的服务，连写/读库查数据。
连写库的原因是：可能有些接口无法接受主从延迟受的影响。这个酌情添加。
可以通过业务类型拆分：按照业务领域、边界，对请求量大的模块进行独立提供服务。</description>
    </item>
    
    <item>
      <title>生产环境OOM定位</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E7%A8%B3%E5%AE%9A%E6%80%A7/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83oom%E5%AE%9A%E4%BD%8D/</link>
      <pubDate>Sun, 25 Jun 2023 10:54:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E7%A8%B3%E5%AE%9A%E6%80%A7/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83oom%E5%AE%9A%E4%BD%8D/</guid>
      <description> 工具：eclipse memory analyzer mac 配置 -startup ../Eclipse/plugins/org.eclipse.equinox.launcher_1.5.0.v20180512-1130.jar -data /Users/nenglianjituan/mat-log --launcher.library ../Eclipse/plugins/org.eclipse.equinox.launcher.cocoa.macosx.x86_64_1.1.700.v20180518-1200 -vm /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/bin -vmargs -Xmx4096m -Dorg.eclipse.swt.internal.carbon.smallFonts -XstartOnFirstThread curl -X POST &amp;ndash;location &amp;ldquo;http://localhost:8080/services/tools/modify/to/refund&amp;rdquo; -H &amp;ldquo;Content-Type: application/json&amp;rdquo; -d &amp;ldquo;{&amp;quot;paySn&amp;quot;: &amp;quot;226235742551281664&amp;quot;}&amp;rdquo;
工具：IDEA Profiler com.czb.finance.report.dto.excel.NlFinanceVourcherInfoExportDTO 0xc49defa8 com.czb.finance.report.dto.excel.NlFinanceVourcherInfoExportDTO 0xc49df1c8
导入hprof文件 分析结果 右击类，在新选项卡中打开，可以观测每个对象信息 其中： 计数 表示对象有多少个 浅层 表示 保留 表示所有对象占用的空间
工具：JProfiler </description>
    </item>
    
    <item>
      <title>Dperf教程 - 1 - 介绍</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/dperf-%E5%8E%8B%E6%B5%8B/dperf-1-%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Wed, 21 Jun 2023 16:18:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/dperf-%E5%8E%8B%E6%B5%8B/dperf-1-%E4%BB%8B%E7%BB%8D/</guid>
      <description>https://www.oschina.net/p/dperf dperf 是一款由百度开源的超高性能的网络压力测试仪。
它使用了 DPDK 与用户态 TCP 协议栈技术，用一台 x86 服务器就可以制造巨大流量：数 10 亿并发连接，百 Gbps 吞吐，千万级 HTTP CPS，其性能远远超过商业测试仪。它还能够精确显示全链路的丢包数，能够帮助你准确找到被测设备性能瑕疵。
它既可以对用来对四层网关、交换机进行性能测试，也可用来测评 CPU 的网络报文处理能力。</description>
    </item>
    
    <item>
      <title>0x01.Nginx安装与部署</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/nginx-web%E4%B8%8E%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/0x01.nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Tue, 20 Jun 2023 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/nginx-web%E4%B8%8E%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/0x01.nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</guid>
      <description>mac安装brew $ ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
mac安装nginx $ brew install nginx
查看安装位置 $ brew info nginx -p prefix : set prefix path (default: /usr/local/Cellar/nginx/1.25.3/)
指定or默认配置文件位置 -c filename : set configuration file (default: /usr/local/etc/nginx/nginx.conf)
指定or默认操作 -s signal : send signal to a master process: stop, quit, reopen, reload
指定or默认error.log位置 -e filename : set error log file (default: /usr/local/var/log/nginx/error.log)
启动 nginx</description>
    </item>
    
    <item>
      <title>0x01.PlantUML-IDEA的示例与使用</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/plantuml-%E7%94%BB%E5%9B%BE%E5%B7%A5%E5%85%B7/0x01.plantuml%E5%9C%A8idea%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 20 Jun 2023 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/plantuml-%E7%94%BB%E5%9B%BE%E5%B7%A5%E5%85%B7/0x01.plantuml%E5%9C%A8idea%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description> 时序图 legend center 台账服务资金账单拉取 end legend autonumber JOB -&amp;gt; Ledger: 触发: 携带商户号 activate Ledger Ledger -&amp;gt; Apollo: 获取商户参数 activate Apollo Apollo --&amp;gt; Ledger: 商户参数: 证书地址、私钥.. deactivate Ledger -&amp;gt; Ledger: init至上下文 activate Ledger Ledger -&amp;gt; Ledger: 依据商户号，确定流程 deactivate Ledger -&amp;gt; Handler: 执行doAction，启动流程 Handler -&amp;gt; Arounder: 任务重入判断 Handler -&amp;gt; Downloader: 下载账单 Handler -&amp;gt; Extractor: 处理账单数据并入库 Ledger --&amp;gt; JOB: 任务执行完成 deactivate Ledger group 分组示例 group 示例1 Extractor -&amp;gt; Extractor: xxxxx end group 示例2 Extractor --&amp;gt; Extractor: xxxxx end end 用例图 left to right direction actor Guest as g package Professional { actor Chief as c actor &amp;#34;Food Critic&amp;#34; as fc } package Restaurant { usecase &amp;#34;Eat Food&amp;#34; as uc1 usecase &amp;#34;Pay For Food&amp;#34; as uc2 usecase &amp;#34;Drink&amp;#34; as uc3 usecase &amp;#34;Review&amp;#34; as uc4 } g--&amp;gt; uc1 g--&amp;gt; uc2 g--&amp;gt; uc3 fc--&amp;gt; uc4 类图 @startuml class Person { + String 公有属性 # String 继承 - String 私有属性 + void 公有方法() } class Student { - String 私有属性1 + void study() } class Teacher { - String 私有属性2 - void 私有方法() } Person &amp;lt;|-- Student Person &amp;lt;|-- Teacher @enduml 活动图(流程图) @startuml title 生成确认单流程 start :操作一; :操作二; switch(判断条件) case(流程1) :流程1; if (判断条件1) then (否) :不满足条件分支; stop else (是) :满足条件分支; endif :跳出判断条件1; case(流程2) :流程2; case(流程3) :流程3; if (判断条件2) then (是) :符合判断条件2; stop else (否) :不符合; endif endswitch :准备结束; stop @enduml 思维导图 +[#17ADF1] mall学习路线 ++[#lightgreen] 推荐资料 ++[#lightblue] 后端技术栈 +++_ 项目框架 +++_ 数据存储 +++_ 运维部署 +++_ 其他 ++[#orange] 搭建项目骨架 ++[#1DBAAF] 项目部署 +++_ Windows下的部署 +++_ Linux下使用Docker部署 +++_ Linux下使用Docker Compose部署 +++_ Linux下使用Jenkins自动化部署 --[#1DBAAF] 电商业务 ---_ 权限管理模块 ---_ 商品模块 ---_ 订单模块 ---_ 营销模块 --[#orange] 技术要点 --[#lightblue] 前端技术栈 --[#lightgreen] 进阶微服务 ---_ Spring Cloud技术栈 ---_ 项目部署 ---_ 技术要点 --[#yellow] 开发工具 --[#lightgrey] 扩展学习 部署图 </description>
    </item>
    
    <item>
      <title>0x02.Nginx搭建静态资源服务器</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/nginx-web%E4%B8%8E%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/0x02.nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Tue, 20 Jun 2023 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/nginx-web%E4%B8%8E%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/0x02.nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>确认 Nginx 的配置文件位置 通常是/etc/nginx/nginx.conf或/etc/nginx/conf.d/default.conf
配置静态文件服务器的根目录 server { listen 80; # 监听的端口 server_name localhost; # 服务器名称 # 定义根目录 root /path/to/your/static/files; # 替换为你的静态文件所在的目录路径 # 索引文件 index index.html; # 禁止访问其他目录 location / { deny all; } } 重启 Nginx nginx -s reload
确认环境 另外，确保服务器在局域网内具有可访问性，并允许适当的端口通过防火墙。</description>
    </item>
    
    <item>
      <title>Arthas教程 - 1 - 安装与使用</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/arthas-%E7%BA%BF%E4%B8%8A%E7%9B%91%E6%8E%A7/arthas%E6%95%99%E7%A8%8B-1-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 20 Jun 2023 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/arthas-%E7%BA%BF%E4%B8%8A%E7%9B%91%E6%8E%A7/arthas%E6%95%99%E7%A8%8B-1-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description> java环境变量 # java mac export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_291.jdk/Contents/Home export CLASSPATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$JAVA_HOME/bin:$PATH 下载工具&amp;amp;启动 curl -O https://arthas.aliyun.com/arthas-boot.jar java -jar arthas-boot.jar
命令-描述-使用 dashboard - 显示进程、线程、服务信息 - dashboard jad - 显示代码 - jad package.ClassName watch - 显示方法返回值 - watch package.ClassName methodName returnObj </description>
    </item>
    
    <item>
      <title>Arthas教程 - 2 - retransform redefine 动态加载class</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/arthas-%E7%BA%BF%E4%B8%8A%E7%9B%91%E6%8E%A7/arthas%E6%95%99%E7%A8%8B-2-retransform-redefine-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDclass/</link>
      <pubDate>Tue, 20 Jun 2023 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/arthas-%E7%BA%BF%E4%B8%8A%E7%9B%91%E6%8E%A7/arthas%E6%95%99%E7%A8%8B-2-retransform-redefine-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDclass/</guid>
      <description> 使用arthas的mc编译java文件 jad --source-only com.czb.finance.bill.controller.RedisTest &amp;gt; /czb/server_logs/czb-finance-bill/RedisTest.java mc /czb/server_logs/czb-finance-bill/RedisTest.java -d /czb/server_logs/czb-finance-bill 到这步报错：Compilation Error；改用本地编译方式 本地编译出class文件，上传到服务器 办法一 临时class文件上传到https://ac-data.info/ 获取url接口的response，进行curl -o 下载 curl -o RedisTest.class &amp;#34;https://objectstorage.ap-tokyo-1.oraclecloud.com/p/UXlqZOF7wz5ZQEEbrdAbiWZd7GChkpQdHccApnoj-cW6eXjUGo3uTUgeym9IAMFO/n/nrqww3senroj/b/oracle.ac-data.info/o/8fd32d16-57e6-4b76-9ac2-8dde60f46337/RedisTest.class&amp;#34; curl -o RedisTestQueryRequestAndResponse.class &amp;#34;https://objectstorage.ap-tokyo-1.oraclecloud.com/p/ckE_vVm2AOjkFynFc9ns6vGQosRRGn5--idp0JR488Ry43F3_LhcjQn6PdvV4nsb/n/nrqww3senroj/b/oracle.ac-data.info/o/8fd32d16-57e6-4b76-9ac2-8dde60f46337/RedisTest$QueryRequestAndResponse.class&amp;#34; 办法二 在本地先转换.class文件为 base64，再保存为 xxx.txt base64 &amp;lt; RedisTest.class &amp;gt; xxx.txt 把内容copy到服务器，再还原内容 base64 -d &amp;lt; xxx.txt &amp;gt; RedisTest.class 使用redefine操作class [arthas@158661]$ redefine /czb/server_logs/czb-finance-bill/RedisTest.class load class file failed: /czb/server_logs/czb-finance-bill/RedisTest.class, error: java.lang.IllegalArgumentException: Unsupported class file major version 8762 发现保存类似jdk版本问题，再去下载个与服务器一样的版本 </description>
    </item>
    
    <item>
      <title>Hugo教程 - 1 - 安装与部署</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/hugo-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93/hugo%E6%95%99%E7%A8%8B-1-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Tue, 20 Jun 2023 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/hugo-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93/hugo%E6%95%99%E7%A8%8B-1-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</guid>
      <description>安装brew $ ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
安装hugo $ brew install hugo
验证hugo which hugo /usr/local/bin/hugo ls -l $( which hugo ) lrwxr-xr-x 1 nenglianjituan admin 31 6 15 17:04 /usr/local/bin/hugo -&amp;gt; ../Cellar/hugo/0.113.0/bin/hugo hugo version hugo v0.113.0+extended darwin/amd64 BuildDate=unknown 使用hugo # 初始化一个项目(此时有结构，但是还不能使用) hugo new site hugoblog cd hugoblog # 创建文章 (content/post) hugo new post/document.md (真实目录创建在：content/post/document.md) # 下载一款皮肤 （安装皮肤 &amp;amp; 启动服务） cd hugoblog git clone https://github.com/spf13/hyde.git themes\hyde # 指定皮肤，启动服务 hugo server -D -t hyde --buildDrafts 扩展-皮肤下载地址 试看主题效果 1.</description>
    </item>
    
    <item>
      <title>Hugo教程 - 2 - 结构介绍</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/hugo-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93/hugo%E6%95%99%E7%A8%8B-2-%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Tue, 20 Jun 2023 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/hugo-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93/hugo%E6%95%99%E7%A8%8B-2-%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/</guid>
      <description>目录结构 . ├── archetypes (存放 front matter（前置数据）) ├── config.toml (全局配置文件) ├── content (存放网页的主要内容 Markdown 文件) ├── data (存放数据文件，通常是 json/yaml/toml 文件) ├── layouts (存放 HTML 模板) ├── static (存放静态文件，会被直接复制到 public 目录下) └── themes (存放现有的主题模板) content └── content ├── _index.md // https://example.com/ ├── about.md // https://example.com/about/ ├── posts | ├── _index.md // https://example.com/posts/ | ├── firstpost.md // https://example.com/posts/firstpost/ 模板(layouts、themes；layouts优先级高)语法 Hugo 使用 Go 语言的 html/template 库 作为模版引擎， 模板的标签为 {{}} , {{}} 中包含的内容叫“动作”</description>
    </item>
    
    <item>
      <title>Hugo教程 - 3 - 配置文件讲解</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/hugo-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93/hugo%E6%95%99%E7%A8%8B-3-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 20 Jun 2023 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/hugo-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93/hugo%E6%95%99%E7%A8%8B-3-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid>
      <description>hugo.toml # 网站地址 baseURL = &amp;#39;https://huangruiying.github.io/&amp;#39; # 网站语言 languageCode = &amp;#34;en-us&amp;#34; # 网站title title = &amp;#39;hugo.toml-title&amp;#39; # 主题的名字，这个要跟myblog/themes 目录中的子目录的目录名一致 theme = &amp;#34;hyde&amp;#34; # home/category/tag 页面显示的文章数 (Default: 10) paginate = 2 # home/category/tag 页面用于摘要的字数 (Default: 70) summaryLength = 10 在模板中使用配置文件定义的数据 在sidebar.html内使用BaseURL 在模板内使用常量
常量在hugo.toml中定义： baseURL = &amp;#39;https://huangruiying.github.io/&amp;#39; 常量在模板使用： {{ .Site.BaseURL }} 在模板内使用数组，循环生成标题
数组在hugo.toml中定义： [[menu.sidebar]] name = &amp;#34;新浪&amp;#34; url = &amp;#34;https://www.sina.com&amp;#34; [[menu.sidebar]] name = &amp;#34;Github&amp;#34; url = &amp;#34;https://github.com&amp;#34; 数组在模板使用： {{ range .Site.Menus.sidebar -}} &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;{{.</description>
    </item>
    
    <item>
      <title>Perf4j 介绍</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/perf4j/perf4j%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Tue, 20 Jun 2023 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/perf4j/perf4j%E4%BB%8B%E7%BB%8D/</guid>
      <description>org.perf4j perf4j ${perf4j.version} Perf4J 是一个 Java 的性能记录、监测和分析库，主要功能如下： 监测应用程序性能：支持监测 Java 应用程序的各种性能指标，如内存使用情况、CPU 使用情况、线程状态等。 实时分析性能数据：支持实时分析性能数据，帮助开发者快速定位性能问题。 可视化性能数据：支持将性能数据以图表的形式展示，方便开发者对性能数据进行分析和比较。 支持分布式环境：支持在分布式环境中进行性能监测和分析。 支持自定义监测指标：支持自定义监测指标，方便开发者根据自己的需求进行监测和分析。 总的来说，Perf4J 是一个功能强大的性能监控和分析框架，提供了丰富的功能和工具，帮助开发者快速定位和解决性能问题。
使用方式 @Profiled(tag = &amp;ldquo;PayDetailService.beforePay&amp;rdquo;)</description>
    </item>
    
    <item>
      <title></title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3cacheable%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3cacheable%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>SpringBoot-功能实现-缓存注解Cacheable的使用.md</description>
    </item>
    
    <item>
      <title></title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E6%B5%81%E7%A8%8B-%E4%BB%A3%E7%90%86%E7%9A%84%E5%88%87%E5%85%A5%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/springframework/springboot-%E6%B5%81%E7%A8%8B-%E4%BB%A3%E7%90%86%E7%9A%84%E5%88%87%E5%85%A5%E6%B5%81%E7%A8%8B/</guid>
      <description>CglibAopProxy#intercept
MethodProxy#invoke</description>
    </item>
    
    <item>
      <title></title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E5%8F%98%E9%87%8F%E7%9A%84%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/java/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E5%8F%98%E9%87%8F%E7%9A%84%E6%B3%9B%E5%9E%8B/</guid>
      <description>运行时，通过反射获取List泛型
public class Main { public static void main(String[] args) { // 创建一个 List 对象，使用 String 作为泛型类型 List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); // 获取 List 的实际类型 Type genericType = list.getClass().getGenericSuperclass(); // 如果类型不是 ParameterizedType，表示没有使用泛型 if (genericType instanceof ParameterizedType) { // 获取泛型类型 ParameterizedType parameterizedType = (ParameterizedType) genericType; // 获取第一个类型参数 Type type = parameterizedType.getActualTypeArguments()[0]; // 打印类型 System.out.println(&amp;#34;List 的泛型类型为: &amp;#34; + type); } else { System.out.println(&amp;#34;List 没有使用泛型&amp;#34;); } } } // 获取对象泛型 public Class getParameterizedType(Object o) { ParameterizedType genericSuperclass = (ParameterizedType) o.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/shell/%E6%93%8D%E4%BD%9C-vim-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/shell/%E6%93%8D%E4%BD%9C-vim-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</guid>
      <description>指定编码打开文件 vim &amp;ldquo;+e ++enc=编码名称&amp;rdquo; xxx.log
文本替换 需要转译的字符 /\ /. 替换当前行首个a为b :s/a/b/ 替换当前行所有a为b :s/a/b/g 替换第n行开始,到最后一行为止,每一行的第一个a为b :n,$s/a/b/ 替换第n行开始,到最后一行为止,每一行所有a为b; n为数字若n为.，表示从当前行起 :n,$s/a/b/g 替换每一行的首个a为b :%s/a/b/ 替换每一行中所有a为b :%s/a/b/g 解决斜杠问题 s/vip-executor.jar//home/pay/huangruiying/vip-executor/four-element/vip-executor.jar/ 替换以 | 结尾的字符，替换为 ; :%s/|$/;/g
%s/|INSERT/INSERT/g %s/|$//g %s/czb_payment/czb_finance_settle/g
文本输入 o:在当前行下一行输入 i:在当前字符前输入 a:在当前字符后输入
光标移动 w e: 光标右移一个单词 到字首/尾 W E: 光标右移一句话 到字首/尾 b B: 光标左移一个字/一句话到字首 ) :光标移至句尾 ( :光标移至句首 } :光标移至段落开头 { :光标移至段落结尾 nG:光标移至第n行首 n :光标下移n行
查找 n 下一个 N 上一个 k ctrl+p: 上一行 j ctrl+n: 下一行 h 删除: 左移一字符 l 空格: 右移一字符</description>
    </item>
    
    <item>
      <title></title>
      <link>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>https://blog.csdn.net/u013309870/article/details/75193592
动态规划算法核心：记住已经解决过的子问题的解 实现动态规划堆方法有两个 1 自顶向下的备忘录法 2 自底向上
自顶向下的备忘录法 对于每个子问题的结果进行存储，当类似递归的算法，再执行到子问题时，可以直接使用，无须再计算。
自底向上</description>
    </item>
    
    <item>
      <title></title>
      <link>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%A0%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%A0%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%A0%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%A0%88/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%A0%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%A0%91/</guid>
      <description> 先序遍历 中左右 中序遍历 左中右 后序遍历 左右中 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E8%B7%B3%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/0.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E8%B7%B3%E8%A1%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%BC%8Finterpreter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%BC%8Finterpreter/</guid>
      <description>Expression: 解析器对象 E1 imp Expression E2 imp Expression
Context: 待处理数据对象 List
解析器注册到上下文(待处理数据)中 ctx.reg(E1&amp;hellip;En)
执行解析器 for e in ctx.getExpressionList e.interpreter(ctx)</description>
    </item>
    
    <item>
      <title></title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/1.%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E4%BB%BB%E5%8A%A1%E5%88%86%E7%89%87/%E5%88%86%E7%89%87%E5%B9%BF%E6%92%AD%E5%9C%A8xxljob%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/1.%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E4%BB%BB%E5%8A%A1%E5%88%86%E7%89%87/%E5%88%86%E7%89%87%E5%B9%BF%E6%92%AD%E5%9C%A8xxljob%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>背景：1个离线任务执行30h，但是要求一天内执行完毕，由于单机吞吐量，处理性能无法打满发布服务的接口， 故可以采用分片的模式进行对任务分布式执行
目的：降低单个任务的执行时间
实现：在任务调度时，可以通过调度者(任务调度中心)向任务执行器(实际触发的项目)携带分片数据 比如index(当前第几片，0起始) total(共几台机器，可执行任务的机器数量) 此时两参数透传到dao层，where中添加「 AND mod(id,#{number}) = #{index} 」 //number 分片总数，index当前分片数 进行过滤数据，即可实现多任务分片
获取当前分片 ShardingUtil.ShardingVO shardingVO = ShardingUtil.getShardingVo(); shardingVO.getIndex()</description>
    </item>
    
    <item>
      <title></title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/1.%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/0x01.%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/1.%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/0x01.%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E6%A1%86%E6%9E%B6/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/1.%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/0x01.%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E5%AE%9E%E7%8E%B0%E6%94%AF%E4%BB%98%E9%80%9A%E9%81%93%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/1.%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/0x01.%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E5%AE%9E%E7%8E%B0%E6%94%AF%E4%BB%98%E9%80%9A%E9%81%93%E8%B7%AF%E7%94%B1/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/0x06.%E6%94%AF%E4%BB%98%E8%A1%8C%E4%B8%9A%E7%8E%A9%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E9%A2%98%E7%A0%94%E7%A9%B6/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/0x06.%E6%94%AF%E4%BB%98%E8%A1%8C%E4%B8%9A%E7%8E%A9%E6%B3%95/</guid>
      <description>手续费：
跳码：A行业pos机手续费10%，在支付公司签约时签B行业2%手续费的pos，然后支付公司收5%，赚3%。
间连：通过使用易宝、汇付对接的微信、支付宝服务商模式，进行降低费率。</description>
    </item>
    
  </channel>
</rss>
