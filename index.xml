<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>博客</title>
    <link>https://huangruiying.github.io/</link>
    <description>Recent content on 博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 24 Aug 2023 15:33:40 +0800</lastBuildDate><atom:link href="https://huangruiying.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Photography</title>
      <link>https://huangruiying.github.io/projects/photography/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/projects/photography/</guid>
      <description>Sometimes I take pictures This project is about the pictures I take. Sometimes, they are pictures of cats.</description>
    </item>
    
    <item>
      <title>Design</title>
      <link>https://huangruiying.github.io/projects/design/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/projects/design/</guid>
      <description>This theme was designed by Victoria Drake. Go on, explore! 💪
If you want to use it for your website, check out the section at the bottom of the main page. 👍</description>
    </item>
    
    <item>
      <title>Writing</title>
      <link>https://huangruiying.github.io/projects/writing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/projects/writing/</guid>
      <description>Aromatic aroma con panna, crema so coffee robust coffee barista, café au lait trifecta that strong blue mountain cortado aftertaste. Aroma extraction french press, skinny sweet, blue mountain cup roast barista, beans, extra cappuccino mug crema strong.
To go viennese cream to go, flavour, so mocha as, carajillo iced et a siphon froth. Aged, eu, cup, brewed aroma kopi-luwak, coffee, id viennese french press brewed grounds acerbic froth. Decaffeinated acerbic, spoon beans seasonal, french press café au lait mazagran roast chicory, pumpkin spice galão as fair trade, dark irish cup ristretto half and half whipped shop.</description>
    </item>
    
    <item>
      <title>场景下设计模式的最佳实践</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E5%AE%9E%E6%93%8D%E5%9C%BA%E6%99%AF%E4%B8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Thu, 24 Aug 2023 15:33:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E5%AE%9E%E6%93%8D%E5%9C%BA%E6%99%AF%E4%B8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid>
      <description> &amp;ndash; </description>
    </item>
    
    <item>
      <title>JVM参数: -javaagent介绍与使用</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/java/jvm%E5%8F%82%E6%95%B0-javaagent%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/java/jvm%E5%8F%82%E6%95%B0-javaagent%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description>代理 (agent) 是在你的main方法前的一个拦截器 (interceptor)，也就是在main方法执行之前，执行agent的代码。 agent的代码与你的main方法在同一个JVM中运行，并被同一个system classloader装载，被同一的安全策略 (security policy) 和上下文 (context) 所管理。
叫代理（agent）这个名字有点误导的成分，它与我们一般理解的代理不大一样。java agent使用起来比较简单。
怎样写一个java agent? 只需要实现premain这个方法
public static void premain(String agentArgs, Instrumentation inst) JDK 6 中如果找不到上面的这种premain的定义，还会尝试调用下面的这种premain定义：
public static void premain(String agentArgs) 2. Agent 类必须打成jar包，然后里面的 META-INF/MAINIFEST.MF 必须包含 Premain-Class这个属性。
下面是一个MANIFEST.MF的例子：
Manifest-Version: 1.0 Premain-Class:MyAgent1 Created-By:1.6.0_06 然后把MANIFEST.MF 加入到你的jar包中。
所有的这些Agent的jar包，都会自动加入到程序的classpath中。所以不需要手动把他们添加到classpath。 除非你想指定classpath的顺序。
一个java程序中-javaagent这个参数的个数是没有限制的，所以可以添加任意多个java agent。
所有的java agent会按照你定义的顺序执行。 例如：
java -javaagent:MyAgent1.jar -javaagent:MyAgent2.jar -jar MyProgram.jar 假设MyProgram.jar里面的main函数在MyProgram中。
MyAgent1.jar, MyAgent2.jar, 这2个jar包中实现了premain的类分别是MyAgent1, MyAgent2 程序执行的顺序将会是
MyAgent1.premain -&amp;gt; MyAgent2.premain -&amp;gt; MyProgram.main 5. 另外，放在main函数之后的premain是不会被执行的，</description>
    </item>
    
    <item>
      <title>创建型模式-抽象工厂</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/</guid>
      <description>创建型模式 创建对象的最佳方式
通过FactoryProducer 工厂创造器创建一个工厂</description>
    </item>
    
    <item>
      <title>创建型模式-建造者模式</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>创建型模式 提供了创建对象的最佳方式
主要解决 复杂对象的创建工作，由于需求变化会导致复杂对象时刻面临巨大变化，但是将他们组合在一起的算法相对稳定。
何时使用 一些基本部件不会变，而其组合经常变化的时候。
如何解决 将变与不变分离开。
关键代码 建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。
应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的&amp;quot;套餐&amp;quot;。 2、JAVA 中的 StringBuilder。
优点： 1、建造者独立，易扩展。 2、便于控制细节风险。
缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。
使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。
注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</description>
    </item>
    
    <item>
      <title>创建型模式-享元模式</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid>
      <description> 核心思想（复用） 运用共享技术，针对需要大量创建的相同对象(Circle)，但对象间只有极少属性(x,y,r)有区别，所以可以重复利用一个对象，写入属性后使用。 使用场景 在有创建大量对象，可能会占用很大部分内存，导致内存溢出 或频繁GC消耗cpu。 支持工厂模式缓存 --- 大量调用工厂创建对象方法时，可以在保证对象全局变量没有线程安全问题的前提下，跳过创建，直接重复吐相同对象。 工厂类Factory&amp;lt;Type&amp;gt; 全局变量Map&amp;lt;String,Type&amp;gt; 获取对象 Map.get(Str) 查询产品中心场景 --- 大量请求涌入，条件相同时，可以使用享元，第一个对象缓存，后续直接从缓存拿数据。 实现思路(FlyweightFactory（享元工厂类）ConcreteFlyweight（具体享元类）) 我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。 区别对比 与对象池的区别 对象池化：目的是降低对象创建带来的资源消耗(预创建+动态创建+闲时回收)、对象重复使用、且同一时刻对象只被一处使用（独占）。 享元模式：用时不存在时动态创建，不回收。同一时刻同一对象可由多方使用，对象共享。 与缓存模式的区别： 缓存：主打通过存储数据，提高效率。 享元模式：主打对象的复用。 public class ShapeFactory { private static final Map&amp;lt;String, Shape&amp;gt; circleMap = new HashMap&amp;lt;&amp;gt;(); public static Shape getCircle(String color) { // 获取对象 Circle circle = (Circle) circleMap.get(color); if (circle == null) { // 不存在时写入 circle = new Circle(color); circleMap.put(color, circle); } return circle; } } </description>
    </item>
    
    <item>
      <title>结构型模式-适配器模式</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>核心思想 负责兼容差异，作为两个不兼容的接口的桥梁（适配） 将一个类的接口转换成客户希望的另外一个接口。使原本由于接口不兼容而不能一起工作的那些类可以一起工作。 主要解决在软件系统中，常常要将一些&amp;quot;现存的对象&amp;quot;放到新的环境中，而新环境要求的接口是现对象不能满足的。 使用场景 业务网关：将外部不同接口、不同字段，映射为内部标准字段 美国电器 110V，中国电器 220V，就要有一个适配器将 110V 转化为 220V JAVA 中的 jdbc。 接口兼容：通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。） 实现思路（Decorator） 区别对比 应用实例：
优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。
缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。 因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</description>
    </item>
    
    <item>
      <title>结构型模式-装饰器模式</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description> 核心思想 在不改变对象自身的基础上，通过对目标类的包装，实现对该类的扩展。 可以在程序动态运行期间，扩展对象功能。 一般，我们为了扩展一个类，经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。与继承相比，装饰者是一种更轻便灵活的做法 缺点是： 增加了很多小对象，增大系统复杂性，所以在项目结构上要分类好。 被多次装饰的对象，出错时不好排查。 使用场景 在不想增加很多子类的情况下扩展类，使用装饰器。 实现思路（Decorator） 角色：AbsDecorator、XxxDecorator AbsDecorator:抽象装饰类 XxxDecorator:实际拓展类 区别对比 与代理模式区别 代理模式：对象是代理对象创建的。 装饰器模式：对象是通过构造参数传入的。 public abstract class AbsDecorator implements 被装饰类|待扩展类 { protected 被装饰类|待扩展类 decoratedShape; public AbsDecorator(Shape decoratedShape){ this.decoratedShape = decoratedShape; } public void draw(){ decoratedShape.draw(); } } public class XxxDecorator extends AbsDecorator { public XxxDecorator(Shape decoratedShape) { super(decoratedShape); } @Override public void draw() { decoratedShape.draw(); // 扩展的功能 setRedBorder(decoratedShape); } private void setRedBorder(Shape decoratedShape){ System.out.println(&amp;#34;Border Color: Red&amp;#34;); } } </description>
    </item>
    
    <item>
      <title>设计模式概述</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</guid>
      <description>设计模式分为创建型模式、结构型模式、
创建型模式 工厂模式 抽象工厂模式 单例模式 原型模式 建造者模式 享元模式
结构型模式 适配器模式
开发时对于某些特定功能的类的命名规范 Wrapper、Holder、Handler、Handle、Dispatcher 傻傻分不清? - Wrapper： - Holder：持有者，比如存储线程上下文的线程副本，可以放在线程副本holder内，提供对外操作入口 - Handler：句柄，就是 - Handle：资源的抽象引用 VO、DTO、Request、Response 傻傻分不清 - Request: 接口调用者传入参数的载体 - DTO: 数据载体，数据在某服务、多方法间传输时使用(方法调用时的传参) - VO: 接口返回给页面的数据对象 - Response: 响应给页面的结果对象，包含VO ``` public class ParamRequest{ // 数据载体1 private RuleDTO ruleDto; // 数据载体2 private InfoDTO infoDto; } public class ResultResponse&amp;lt;T&amp;gt; implements Serializable { // 业务状态码 private String code; // 响应信息 private String message; // 数据 VO private T data; } ``` </description>
    </item>
    
    <item>
      <title>行为型模式-策略模式</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>核心思想 通过预先创建好多种行为，为不通场景提供服务
使用场景 对接多家支付通道时，每种支付通道对接方式是一种策略
实现思路 角色：Context、AbsStrategy、ApplyStrategy Context：根据传入条件，选择具体策略 AbsStrategy：定义策略功能与部分流程，主要包含接口和抽象类 ApplyStrategy：具体的应用策略</description>
    </item>
    
    <item>
      <title>行为型模式-观察者模式</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description> 核心思想 注册观察类到被观察的对象全局观察者列表中，让被观察对象知道有哪些类在观察它的变化，从而方便被观察者通知每个自身变化到观察者列表内。 使用场景 低耦合前提下，目标对象（Subject）的状态变化，观察者对象（Observers）都要接到通知。 实现思路 角色：Subject、Observer Subject：被观察的对象 Observer：观察者集合，Subject的动作要通知到这里。 Observers(List,维护Observer的集合) notifyEveryObserver(在有通知需求时(比如状态变更)，通知到每个Observer，遍历Observer并通知) </description>
    </item>
    
    <item>
      <title>行为型模式-命令模式</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>核心思想 是一种数据驱动的设计模式，它属于行为型模式。 请求以命令的形式包裹在对象中，并传给「调用对象」。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 使用场景 需要线预定义要执行的内容、步骤，后通过触发/定时执行时，可以使用 其他没太想好 实现思路 角色：Order、Stock、Broker Order：命令接口，定义标准的执行方法；用订单举例 execute(){} Stock：请求类，整合了所有可执行的命令；用店铺举例 ApplyStock：具体的命令对象；通过实现Order接口，扩展其执行功能；包装了Stock的每一个可执行的方法(命令)；用买卖举例 implement Order private Stock stock execute(){ stock.command(); } Broker：命令调用对象，维护Orders(ApplyStocks) public interface Order { void execute(); } public class Stock { private String name = &amp;#34;ABC&amp;#34;; private int quantity = 10; public void buy(){ System.out.println(&amp;#34;Stock [ Name: &amp;#34;+name+&amp;#34;,Quantity: &amp;#34; + quantity +&amp;#34; ] bought&amp;#34;); } public void sell(){ System.out.println(&amp;#34;Stock [ Name: &amp;#34;+name+&amp;#34;,Quantity: &amp;#34; + quantity +&amp;#34; ] sold&amp;#34;); } } public class BuyStock implements Order { private Stock abcStock; public BuyStock(Stock abcStock){ this.</description>
    </item>
    
    <item>
      <title>行为型模式-模版方法模式</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
      <description> 核心思想 一个抽象类公开定义了执行它的方法的方式/模板 使用场景 多态时，在抽象类中定义标准执行流程时 可以配合策略模式使用 实现思路 角色：AbsClass、 通过抽象类，明确主流程、主框架，将可能存在差异的地方进行抽象化，供子类自定义 class AbcTemplate&amp;lt;REQ,RES&amp;gt;{ RES do(REQ request){ &amp;quot;template define info &amp;quot;.sout special().sout } // 自定义 protected String special(); } </description>
    </item>
    
    <item>
      <title>行为型模式-事件监听</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/</guid>
      <description>核心思想【是 观察者模式 的一种实现】 生产监听事件到事件池， 监听事件池并获取事件，去执行。
使用场景
实现思路</description>
    </item>
    
    <item>
      <title>行为型模式-状态模式</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid>
      <description> 核心思想 对象的行为依赖于对象状态。通过状态的改变，而改变对象的行为 比如一个逻辑，if(status = 1) : case 1 ; if(status = 2) : case 2 ; 使用场景 离线计算收益时各步骤独立且状态明确; 捞取数据落地(新订单生成收益单、旧收益单)-status=1； 计算status=1的收益，并更新，记status=2； 捞取status=2的数据，通知到下游系统，成功记status=3，失败status=4； 实现思路 角色：Context、AbsState、ApplyState 离线计算收益时，1 捞取数据完成 3 计算收益完成 8 发布收益完成 ProfitState // 收益计算接口 ProfitCalculateContext#setState、getState // 记录任务执行进度 // 需要计算收益的数据捞取 ProfitExtractorState imp ProfitState doAction#执行当前状态需要的操作 // 收益计算 ProfitCalculatorState imp ProfitState // 发布计算好的收益数据 ProfitPublisherState imp ProfitState 调用流程 ctx = new ProfitCalculateContext() new ProfitExtractorState().doAction(ctx) // 开始1状态的执行。 new ProfitCalculatorState().doAction(ctx) // 开始3状态的执行。 new ProfitPublisherState().doAction(ctx) // 开始8状态的执行。 优点是什么？ 流程代码去耦合， 状态转换显示化，减少对象间依赖 状态类职责单一，易于扩展新状态 FAQ: 若有需求在ProfitExtractorState类中修改，该类怎么再进行设计？ </description>
    </item>
    
    <item>
      <title>注解: NotBlank NotEmpty的使用</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/java/%E6%B3%A8%E8%A7%A3-notblank-notempty%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/java/%E6%B3%A8%E8%A7%A3-notblank-notempty%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description> @NotBlank @NotEmpty (javax.validation.constraints.NotBlank) 接口标明 org.springframework.validation.annotation.Validated 注解 要校验的对象标明 javax.validation.Valid 注解 要校验的对象属性标明 javax.validation.constraints.NotBlank 注解 示例： // 接口操作 @PostMapping(&amp;#34;/demo&amp;#34;) @Validated public Wrapper&amp;lt;Response&amp;gt; demo(@RequestBody @Valid Request request) throws Exception { Response response = method(request); return WrapMapper.&amp;lt;Response&amp;gt;ok().result(response); } public class Request { @ApiModelProperty(&amp;#34;开始日期&amp;#34;) @NotBlank(message = &amp;#34;开始日期不能为空&amp;#34;) private String begDate; @ApiModelProperty(&amp;#34;结束日期&amp;#34;) @NotBlank(message = &amp;#34;结束日期不能为空&amp;#34;) private String endDate; } </description>
    </item>
    
    <item>
      <title>Knife4j-接口文档与调试工具</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/knife4j/knife4j-%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 14 Aug 2023 17:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/knife4j/knife4j-%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description> Knife4j Swagger 增强版本 页面友好易操作 有权限认证控制，比swagger安全 支持响应信息JSON折叠 可以导出离线文档 todo https://blog.csdn.net/qing_gee/article/details/122857385 </description>
    </item>
    
    <item>
      <title>SpringBoot-功能实现-配置全局json解析</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E9%85%8D%E7%BD%AE%E5%85%A8%E5%B1%80json%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 31 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E9%85%8D%E7%BD%AE%E5%85%A8%E5%B1%80json%E8%A7%A3%E6%9E%90/</guid>
      <description> </description>
    </item>
    
    <item>
      <title>规则引擎主流算法之RETE算法</title>
      <link>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8Erete%E7%AE%97%E6%B3%95/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E4%B8%BB%E6%B5%81%E7%AE%97%E6%B3%95%E4%B9%8Brete%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 19 Jul 2023 16:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8Erete%E7%AE%97%E6%B3%95/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E4%B8%BB%E6%B5%81%E7%AE%97%E6%B3%95%E4%B9%8Brete%E7%AE%97%E6%B3%95/</guid>
      <description>Fact（事实）：对象之间及对象属性之间的关系
Rule：条件和结论构成的推理语句，一般表示为if…Then。
条件部分，LHS（left-hand-side）
结论部分，RHS（right-hand-side）
Module（模式）：指不能再继续分割下去的最小的原子条件。
模式就是if语句中的条件，但是条件可能是由几个更小粒度的条件组成，所以模式特指不能再继续被分割的最小原子条件。
RETE 算法主要流程 RETE 算法主要流程可以分为以下步骤：
1 Match：找出符合LHS部分的working memory集合 2 Confilict resolution：选出一个条件被满足的规则 3 Act：执行RHS的内容 4 返回第一步 </description>
    </item>
    
    <item>
      <title>Calcite 校验SQL</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/calcite/calcite%E6%A0%A1%E9%AA%8Csql/</link>
      <pubDate>Tue, 18 Jul 2023 20:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/calcite/calcite%E6%A0%A1%E9%AA%8Csql/</guid>
      <description></description>
    </item>
    
    <item>
      <title>DynamicTP线程池介绍</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/dynamictp/dynamictp%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Tue, 18 Jul 2023 20:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/dynamictp/dynamictp%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%8B%E7%BB%8D/</guid>
      <description>美团动态线程池 解决了什么问题? 动态调整线程池大小：Dynamic-Tp可以根据当前负载情况动态调整线程池的大小，从而保证程序的高效性和稳定性。 任务调度和优先级管理：Dynamic-Tp支持任务调度和优先级管理，可以根据任务类型和重要程度自动调整任务的执行优先级。 任务队列管理：Dynamic-Tp支持任务队列管理，可以根据任务类型、重要程度和执行时间等因素对任务队列进行优化。 异常处理和容错能力：Dynamic-Tp具有良好的异常处理和容错能力，可以在任务执行过程中自动处理异常，并且保证程序的稳定性。 配置灵活：Dynamic-Tp提供了灵活的配置选项，可以根据实际需求进行调整。 https://dynamictp.cn/guide/middleware/middleware.html</description>
    </item>
    
    <item>
      <title>DynamicTP在SpringBoot中的使用</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/dynamictp/dynamictp%E5%9C%A8springboot%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 18 Jul 2023 20:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/dynamictp/dynamictp%E5%9C%A8springboot%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description> 添加依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dynamic-tp&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 创建 import org.springframework.context.annotation.Bean; class DynamicTPConfigureDemo { @Bean public ThreadPoolExecutor threadPoolExecutor() { DynamicTpThreadPoolExecutor executor = new DynamicTpThreadPoolExecutor(); executor.setCorePoolSize(10); executor.setMaximumPoolSize(50); executor.setQueueCapacity(100); executor.setThreadNamePrefix(&amp;#34;dynamic-tp-thread-&amp;#34;); executor.initialize(); return executor; } } 使用 public class DynamicTPUseDemo { @Autowired private ThreadPoolExecutor threadPoolExecutor; public void use() { threadPoolExecutor.execute(new Runnable() { @Overridepublic void run() { // 任务执行逻辑 } }); } } </description>
    </item>
    
    <item>
      <title>MyBatisPlus-部分源码</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/mybatis-plus/mybatisplus-%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81/</link>
      <pubDate>Tue, 18 Jul 2023 20:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/mybatis-plus/mybatisplus-%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81/</guid>
      <description>MybatisMapperProxy
识别语句类型 MybatisMapperMethod#execute public Object execute(SqlSessi
获取真实SQL MappedStatement#selectList ms.getBoundSql(parameter)
executor </description>
    </item>
    
    <item>
      <title>MyBatisPlus-动态多数据源</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/mybatis-plus/mybatisplus-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/</link>
      <pubDate>Tue, 18 Jul 2023 20:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/mybatis-plus/mybatisplus-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/</guid>
      <description></description>
    </item>
    
    <item>
      <title>MybatisPlus-基础操作</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/mybatis-plus/mybatisplus-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 18 Jul 2023 20:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/mybatis-plus/mybatisplus-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</guid>
      <description> 使用 lambda 实现自定义查询字段 QueryWrapper wrapper = new QueryWrapper&amp;lt;&amp;gt;(); wrapper.select(&amp;quot; DISTINCT receipt_company_name &amp;ldquo;).lambda()&amp;hellip;
使用判空 summaryWrapper.eq(Objects.nonNull(query.getBillType()), MarkingCheckDetail::getBillType, query.getBillType())
this.lambdaQuery() this.lambdaQuery().eq(FinancialReportInfoDetail::getReportId, 1000000001L).list()
IPage page = this.lambdaQuery().eq(FinancialReportInfoDetail::getRuleType, ruleType.getCode()).page(new Page&amp;lt;&amp;gt;(pageNo, 2000));
QueryWrapper及LambdaQueryWrapper </description>
    </item>
    
    <item>
      <title>动态SQL解析器解决方案 - Calcite</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/calcite/calcite%E9%87%8D%E5%86%99sql/</link>
      <pubDate>Tue, 18 Jul 2023 20:11:18 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/calcite/calcite%E9%87%8D%E5%86%99sql/</guid>
      <description>Calcite Apache顶级项目，主要功能包含SQL 解析、SQL 校验、查询优化、SQL 生成器、数据连接。
解析过程
Maven依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.calcite&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;calcite-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.34.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 操作代码 public class CalciteDemo { // 创建解析器 private static final SqlParser.Config mysqlConfig = SqlParser.config() .withLex(Lex.MYSQL) .withCaseSensitive(false) .withCaseSensitive(false)//大小写敏感 .withQuoting(Quoting.BACK_TICK) .withQuotedCasing(Casing.TO_LOWER) .withUnquotedCasing(Casing.TO_LOWER) .withConformance(SqlConformanceEnum.MYSQL_5); private static final SqlParser.Config oracleConfig = SqlParser.config() .withLex(Lex.ORACLE) .withCaseSensitive(false)//大小写敏感 .withQuoting(Quoting.BACK_TICK) .withQuotedCasing(Casing.TO_LOWER) .withUnquotedCasing(Casing.TO_LOWER) .withConformance(SqlConformanceEnum.ORACLE_12); private static final SqlParser.Config sqlserverConfig = SqlParser.config() .withLex(Lex.SQL_SERVER) .withCaseSensitive(false)//大小写敏感 .withQuoting(Quoting.BACK_TICK) .withQuotedCasing(Casing.TO_LOWER) .withUnquotedCasing(Casing.TO_LOWER) .withConformance(SqlConformanceEnum.SQL_SERVER_2008); // 构建树 SqlNode sqlTree = SqlParser.create(sqlAtomic.get(), mysqlConfig).parseQuery(); /** * 创建自定义查询条件 * * @param where age &amp;gt; 12 and name !</description>
    </item>
    
    <item>
      <title>计算机相关行业专业网站汇总</title>
      <link>https://huangruiying.github.io/%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3%E8%A1%8C%E4%B8%9A%E4%B8%93%E4%B8%9A%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB/</link>
      <pubDate>Mon, 17 Jul 2023 17:18:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3%E8%A1%8C%E4%B8%9A%E4%B8%93%E4%B8%9A%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB/</guid>
      <description> ui设计师聚集的圣地 fe聚集的圣地 全球最大同性交友网站 </description>
    </item>
    
    <item>
      <title>服务指标与SLA服务保障</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%8C%87%E6%A0%87/sla%E6%9C%8D%E5%8A%A1%E4%BF%9D%E9%9A%9C/</link>
      <pubDate>Mon, 17 Jul 2023 10:54:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%8C%87%E6%A0%87/sla%E6%9C%8D%E5%8A%A1%E4%BF%9D%E9%9A%9C/</guid>
      <description> SLA(service level agreement) 即服务品质协议。 一般是客户与服务提供商间达成的服务质量协议。包含正常运行时间、交付时间、响应时间和解决时间等指标。SLA包含SLI和SLO。
SLI(service level indicator) 即服务等级关键量化指标。 指标 含义 适用场景 计算公式 &amp;mdash;&amp;ndash; &amp;mdash;&amp;ndash; &amp;mdash;&amp;mdash; &amp;mdash;&amp;mdash; HA: 高可用（High Availability） 服务可用情况 通用，通常所说的99.9% 99.99% 计划可用时间/(计划可用时间+故障时间)*100 ; 请求成功/(请求成功+请求失败)*100 # 分布式系统 通常使用此计算公式简化复杂情况; 99% 故障时间不超过432分钟/月 7.2小时/月 ; 99.9% 故障时间不超过43.2分钟/月 ; 99.99% 故障时间不超过4.32分钟/月 QPS: 每秒并发量(Queries Per Second) 查询返回能力（每秒） 适合并发查询服务 QPS = 请求成功总数/单位时间 RPS:每秒处理量(Response Per Second) 操作返回能力（每秒） 适合接口多任务服务 TPS: 每秒吞吐量(Transactions Per Second) 事务处理能力（每秒） 适合异步多任务服务 TPS = 任务总数/单位时间 RT: 响应时间(Response Time) 请求响应时间（每秒） 适合所有接口服务 通常关注90%请求算数平均 RT = 单位时间总请求响应时间和/总请求数 并发量 接口用户请求数（每秒） 并不准确与QPS相互估算 并发量 ～= QPS * RT MTBF: 平均出错间隔（Mean Time Between Fail） MTBF = MTTF + MTTR 服务稳定性衡量,越大越好 MTTR: 平均修复时间(Mean Time To Repair) 服务稳定性衡量,越小越好 MTTF: 平均无间隔(Mean time to Failure) 服务稳定性衡量,越大越好 </description>
    </item>
    
    <item>
      <title>SpringBoot-功能实现-过滤器</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E8%BF%87%E6%BB%A4%E5%99%A8/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E8%BF%87%E6%BB%A4%E5%99%A8/</guid>
      <description>本文旨在SpringBoot中如何创建一个过滤器。 直接实现Filter接口+@Component /** * 定义过滤器 */ @Component public class TimeFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(&amp;#34;过滤器初始化&amp;#34;); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException { long start = new Date().getTime(); filterChain.doFilter(request, response); System.out.println(&amp;#34;执行耗时：&amp;#34; + (new Date().getTime() - start)); } @Override public void destroy() { System.out.println(&amp;#34;过滤器销毁&amp;#34;); } } @Bean+@Configuration（第三方Filter）；非@Component标注的filter类 @Configuration public class WebConfig extends WebMvcConfigurerAdapter { @Autowired TimeInterceptor timeInterceptor; @Bean public FilterRegistrationBean charsetFilter() { FilterRegistrationBean registrationBean = new FilterRegistrationBean(); // 注册过滤器到Spring registrationBean.</description>
    </item>
    
    <item>
      <title>SpringBoot-功能实现-拦截器</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E5%88%87%E9%9D%A2/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E5%88%87%E9%9D%A2/</guid>
      <description>本文旨在SpringBoot中如何创建一个切面。</description>
    </item>
    
    <item>
      <title>SpringBoot-功能实现-拦截器</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E6%8B%A6%E6%88%AA%E5%99%A8/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E6%8B%A6%E6%88%AA%E5%99%A8/</guid>
      <description>本文旨在SpringBoot中如何创建一个拦截器。
/** * 定义拦截器 * * @author huangry * Created in 2023/7/21 10:18 */ @Component @Slf4j public class SelfDefineInterceptor extends HandlerInterceptorAdapter { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { log.info(&amp;#34;beg SelfDefineInterceptor&amp;#34;); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { log.info(&amp;#34;end SelfDefineInterceptor&amp;#34;); } } @Configuration public class SelfDefineWebMvcConfigurerAdapter extends WebMvcConfigurationSupport {// WebMvcConfigurer /** * 注册拦截器 */ @Autowired private SelfDefineInterceptor SelfDefineInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { // 注册拦截器,自定义不同拦截器拦截不同的地址 registry.</description>
    </item>
    
    <item>
      <title>SpringBoot-功能实现-日志操作</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E6%97%A5%E5%BF%97/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E6%97%A5%E5%BF%97/</guid>
      <description>自定义日志文件输出：手动生成日志 &amp;amp; 打入指定日志文件 &amp;lt;!-- 定义日志对象及信息 --&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;!-- 定义「指定」日志文件配置 --&amp;gt; &amp;lt;appender name=&amp;#34;httpConsumer&amp;#34; class=&amp;#34;ch.qos.logback.core.rolling.RollingFileAppender&amp;#34;&amp;gt; &amp;lt;file&amp;gt;${LOG_FILE}/consumer.log&amp;lt;/file&amp;gt; &amp;lt;encoder&amp;gt; &amp;lt;pattern&amp;gt;%msg%n&amp;lt;/pattern&amp;gt; &amp;lt;immediateFlush&amp;gt;true&amp;lt;/immediateFlush&amp;gt; &amp;lt;charset&amp;gt;UTF-8&amp;lt;/charset&amp;gt; &amp;lt;/encoder&amp;gt; &amp;lt;rollingPolicy class=&amp;#34;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&amp;#34;&amp;gt; &amp;lt;fileNamePattern&amp;gt;${LOG_FILE}/consumer-%d{yyyy-MM-dd-HH}-%i.log&amp;lt;/fileNamePattern&amp;gt; &amp;lt;maxFileSize&amp;gt;300MB&amp;lt;/maxFileSize&amp;gt; &amp;lt;maxHistory&amp;gt;240&amp;lt;/maxHistory&amp;gt; &amp;lt;CleanHistoryOnStart&amp;gt;true&amp;lt;/CleanHistoryOnStart&amp;gt; &amp;lt;totalSizeCap&amp;gt;60GB&amp;lt;/totalSizeCap&amp;gt; &amp;lt;/rollingPolicy&amp;gt; &amp;lt;/appender&amp;gt; &amp;lt;!-- 定义日志对象及信息 --&amp;gt; &amp;lt;appender name=&amp;#34;asyncHttpConsumer&amp;#34; class=&amp;#34;ch.qos.logback.classic.AsyncAppender&amp;#34;&amp;gt; &amp;lt;appender-ref ref=&amp;#34;httpConsumer&amp;#34;/&amp;gt; &amp;lt;queueSize&amp;gt;1024&amp;lt;/queueSize&amp;gt; &amp;lt;neverBlock&amp;gt;true&amp;lt;/neverBlock&amp;gt; &amp;lt;/appender&amp;gt; &amp;lt;!-- 创建日志对象，java代码里面通过name获取日志句柄 --&amp;gt; &amp;lt;logger name=&amp;#34;http_consumer_log&amp;#34; additivity=&amp;#34;false&amp;#34;&amp;gt; &amp;lt;appender-ref ref=&amp;#34;asyncHttpConsumer&amp;#34;/&amp;gt; &amp;lt;/logger&amp;gt; &amp;lt;/configuration&amp;gt; /** * 输出自定义日志到指定日志文件 &amp;lt;br/&amp;gt; * 例如：http_consumer_log */ public class Loggers { public static void main(String[] args) { // 获取日志对象，并向其输出日志信息 Loggers.getHttpConsumerLogger().info(JSONObject.toJSONString(logMap)); } /** * 我方调用外部服务的日志 */ private static final Logger HTTP_CONSUMER_LOGGER = LoggerFactory.</description>
    </item>
    
    <item>
      <title>SpringBoot-功能实现-日志操作-MDC的使用</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E6%97%A5%E5%BF%97-mdc%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E6%97%A5%E5%BF%97-mdc%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>MDC：Mapped Diagnostic Context，可以粗略的理解成是一个 线程安全的 存放诊断日志的 容器
代码示例 /** * MDC快速入门示例 * * 写REQ_ID到日志中 * */ public class SimpleMDC { private static final Logger logger = LoggerFactory.getLogger(SimpleMDC.class); // REQ_ID 需要在logback.xml 内定义好 public static final String REQ_ID = &amp;#34;REQ_ID&amp;#34;; public static final String TENANT = &amp;#34;Tenant&amp;#34;; public static void main(String[] args) { MDC.put(REQ_ID, UUID.randomUUID().toString()); MDC.put(TENANT, &amp;#34;存放租户ID&amp;#34;); logger.info(&amp;#34;开始调用服务A，进行业务处理&amp;#34;); logger.info(&amp;#34;业务处理完毕，可以释放空间了，避免内存泄露&amp;#34;); MDC.remove(REQ_ID); logger.info(&amp;#34;REQ_ID 还有吗？{}&amp;#34;, MDC.get(REQ_ID) != null); } } logback.xml 示例 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34; ?&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;appender name=&amp;#34;CONSOLE&amp;#34; class=&amp;#34;ch.</description>
    </item>
    
    <item>
      <title>SpringBoot-功能实现-指定数据源执行SQL</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E6%8C%87%E5%AE%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E6%89%A7%E8%A1%8Csql/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/springframework/springboot-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E6%8C%87%E5%AE%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E6%89%A7%E8%A1%8Csql/</guid>
      <description></description>
    </item>
    
    <item>
      <title>SpringBoot-检测方法事物</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/springframework/0x01.%E6%A3%80%E6%B5%8B%E5%BD%93%E5%89%8D%E6%96%B9%E6%B3%95%E4%BA%8B%E7%89%A9%E6%83%85%E5%86%B5/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/springframework/0x01.%E6%A3%80%E6%B5%8B%E5%BD%93%E5%89%8D%E6%96%B9%E6%B3%95%E4%BA%8B%E7%89%A9%E6%83%85%E5%86%B5/</guid>
      <description>方法一:可以通过 TransactionSynchronizationManager#isActualTransactionActive 进行事物情况的判断。
public class TransactionTest{ @Test @Transactional public void test1(){ // 存在 @Transactional 注解时，返回 true; boolear isOpen = TransactionSynchronizationManager.isActualTransactionActive(); } @Test public void test2() { // 删除 @Transactional 注解时，返回 false; boolear isOpen = TransactionSynchronizationManager.isActualTransactionActive(); } } 方法二:可以通过 TransactionSynchronizationRegistry 检测是否存在事物。
import javax.transaction.Status; import javax.transaction.TransactionManager; import javax.transaction.TransactionSynchronizationRegistry; public class TransactionExample { private TransactionManager transactionManager; private TransactionSynchronizationRegistry synchronizationRegistry; public boolean isTransactionActive() { int transactionStatus = synchronizationRegistry.getTransactionStatus(); return transactionStatus == Status.STATUS_ACTIVE; } } </description>
    </item>
    
    <item>
      <title>SpringBoot-接口学习-HandlerMethodArgumentResolver</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/springframework/springboot-%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0-handlermethodargumentresolver/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/springframework/springboot-%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0-handlermethodargumentresolver/</guid>
      <description>HandlerMethodArgumentResolver 是SpringBoot的一个扩展接口，用于解析操作方法参数，由于其只是一个规则定义与数据获取的组件，所以若想使用，还需要知道目标范围，故一般配合拦截器使用。
该接口中一共存在两个方法:
supportsParameter: 作用是匹配规则，当满足本方法的规则时，会执行resolveArgument。 resolveArgument: 作用是具体解析/操作参数。 使用方式 以注入操作用户信息到Controller方法为例
前置条件：需要通过拦截器在请求头拿到token/用户信息，并放入线程副本供后续操作使用。 实现HandlerMethodArgumentResolver接口 public class ContextUserArgumentResolver implements HandlerMethodArgumentResolver { @Override public boolean supportsParameter(@NotNull MethodParameter parameter) { // 判断参数是否是用户信息类型，判断依据(被InjectContextUser注解标记，或者类型为ContextUser) return findMethodAnnotation(InjectContextUser.class, parameter) != null || parameter.getParameterType().isAssignableFrom(ContextUser.class); } @Override public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception { // 通过上下文获取当前用户信息 return ContextHolder.getContext().getContextUser(); } /** * 判断参数是否包含指定注解，若包含，则返回该注解。 * * @param clazz 注解类型 * @param parameter 参数对象 * @return 参数标记的注解对象 */ private &amp;lt;T extends Annotation&amp;gt; T findMethodAnnotation(Class&amp;lt;T&amp;gt; clazz, MethodParameter parameter) { T annotation = parameter.</description>
    </item>
    
    <item>
      <title>SpringBoot-接口学习-InitializingBean</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/springframework/springboot-%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0-initializingbean/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/springframework/springboot-%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0-initializingbean/</guid>
      <description>在设置了所有「当前对象」属性后调用
public class A implements InitializingBean{
}</description>
    </item>
    
    <item>
      <title>0x01.开源数据可视化系统-Davinci</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/davinci-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/0x01.%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F-davinci/</link>
      <pubDate>Wed, 12 Jul 2023 10:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/davinci-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/0x01.%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F-davinci/</guid>
      <description>开源地址 https://github.com/edp963/davinci https://gitee.com/mirrors/Davinci?_from=gitee_search
二次开发 https://dumplingbao.github.io/2020/04/03/davinci-dev-egl/</description>
    </item>
    
    <item>
      <title>Mapstruct用法</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/mapstruct/mapstruct.0x02.%E7%94%A8%E6%B3%95/</link>
      <pubDate>Mon, 10 Jul 2023 18:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/mapstruct/mapstruct.0x02.%E7%94%A8%E6%B3%95/</guid>
      <description>Bean 转 DTO 示例 /** * bean */ public class Car { private String make; private int numberOfSeats; private CarType type; //constructor, getters, setters etc. } /** * dto */ public class CarDto { private String make; private int seatCount; private String type; //constructor, getters, setters etc. } // 第一步：使用 org.mapstruct.Mapper 注解，标记为映射接口。 @Mapper public interface CarMapper { CarMapper INSTANCE = Mappers.getMapper( CarMapper.class ); // 第二步：定义映射方法，明确入参的「源」对象bean，和返回的「目标」对象dto @Mapping(source = &amp;#34;numberOfSeats&amp;#34;, target = &amp;#34;seatCount&amp;#34;) CarDto carToCarDto(Car car); } Maven 依赖 &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>Lombok-常用注解</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/jaxb/jaxb-%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 10 Jul 2023 17:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/jaxb/jaxb-%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description> 是一款java解析xml的插件 使用泛型 // 使用泛型时，要把泛型可能的类型维护到该注解内 @XmlSeeAlso({QsPayInnerReq.class,QsPayOuterReq.class,QsPayQueryReq.class}) @Data @XmlRootElement(name = &amp;#34;BankData&amp;#34;) public class BaseQSReq&amp;lt;T&amp;gt; { @XmlElement(name = &amp;#34;Sign&amp;#34;) private Sign sign; @XmlElement(name = &amp;#34;opReq&amp;#34;) private OpReq opReq; @XmlElement(name = &amp;#34;ReqParam&amp;#34;) private T reqParam; @XmlTransient public Sign getSign() { return sign; } @XmlTransient public OpReq getOpReq() { return opReq; } @XmlTransient public T getReqParam() { return reqParam; } } // 使用泛型后，在标签内生成 xsi:type=&amp;#34;qsPayQueryReq&amp;#34; // 如何从JAXB泛型中删除xsi：type，xmlns：xs和xmlns：xs </description>
    </item>
    
    <item>
      <title>Lombok-常用注解</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/lombok/lombok-%E5%9F%BA%E7%A1%80%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Mon, 10 Jul 2023 17:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/lombok/lombok-%E5%9F%BA%E7%A1%80%E6%B3%A8%E8%A7%A3/</guid>
      <description>@SneakyThrows 将编译时异常包装为运行时异常RuntimeException 代码见 Lombok.sneakyThrow(t);</description>
    </item>
    
    <item>
      <title>Mapstruct介绍</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/mapstruct/mapstruct.0x01.%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 10 Jul 2023 17:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/mapstruct/mapstruct.0x01.%E4%BB%8B%E7%BB%8D/</guid>
      <description>官网解释 what? 这是什么
代码生成器，基于配置方法的约定，简化不同 Java Bean 间映射与转换。 映射关系以普通代码维护，因此快速、类型安全且易于理解。 why? 出现的原因
多层应用程序通常需要在不同的对象模型（例如实体和 DTO）之间进行映射。编写这样的映射代码是一项繁琐且容易出错的任务。MapStruct旨在通过尽可能自动化来简化这项工作。 与其他映射框架相比，MapStruct在编译时生成bean映射，这确保了高性能，允许快速的开发人员反馈和彻底的错误检查。 How?
MapStruct是一个注释处理器，它插入Java编译器，可以在命令行构建（Maven，Gradle等）以及您首选的IDE中使用。 MapStruct使用合理的默认值，但在配置或实现特殊行为时会让你不碍事。 了解更多&amp;hellip;</description>
    </item>
    
    <item>
      <title>Mapstruct介绍</title>
      <link>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/mybatis/mybatis-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-sql%E6%8B%A6%E6%88%AA%E5%99%A8/</link>
      <pubDate>Mon, 10 Jul 2023 17:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%A1%86%E6%9E%B6%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/mybatis/mybatis-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-sql%E6%8B%A6%E6%88%AA%E5%99%A8/</guid>
      <description>Mybatis 执行过程 MyBatis SQL拦截相关注解 /** * 拦截点 */ @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface Intercepts { /** * 定义拦截点 * 只有符合拦截点的条件才会进入到拦截器 */ Signature[] value(); } /** * 拦截条件 */ @Documented @Retention(RetentionPolicy.RUNTIME) @Target({}) public @interface Signature { /** * 定义要拦截的类,范围：Executor、ParameterHandler、StatementHandler、ResultSetHandler * * Executor：拦截执行器的方法 * 执行查询数据：BaseExecutor#query.queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql) * ParameterHandler：拦截参数的处理 * ResultHandler：拦截结果集的处理 * StatementHandler：拦截Sql语法构建的处理 */ Class&amp;lt;?&amp;gt; type(); /** * 定义拦截 {@link this#type()} 中具体哪些方法 */ String method(); /** * 当 {@link this#method()} 在 {@link this#type()} 中存在重名方法时， * 通过参数指定，明确拦截具体哪个方法 * */ Class&amp;lt;?</description>
    </item>
    
    <item>
      <title>对账系统概述</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F/%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Sun, 25 Jun 2023 16:16:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F/%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</guid>
      <description>总体来说，对账系统可抽象为以下流程 其中，获取我方数据可扩展为 获取外部需对账数据可扩展为 数据对比流程 通过代码，捞取DB中固定数据，指定对账双方的对账关系和对账字段，进行比对 缺点：代码需要大量定制，不通用，其他业务线接入对账的成本较高。 塑造对账模板（SQL + 别名 + 条件）、对账配置。 自定义数据模型；通过配置SQL的方式，定义多个数据模板，并有数据标记，用于区分不同业务角度的数据(业务支付单、三方通道支付单等)。 自定义对账配置；通过选择数据模型，生成对账配置，供对账程序使用。 高性能对账程序；开发一套通用的对账程序，读取对账配置并对账。 根据配置指定执行频次、数据捞取范围等数据模型需要的参数，并拿到数据模型进行数据的获取与对比。 使用外部能力，如数据灌入Hive，利用HiveSQL，将数据导出为 核对成功、存疑数据 表。 核对成功：通过SQL，对本端的单边账，结果写入表 存疑数据：对于两端数据非完全一致的，标记数据存疑(可能为 ) 通过SQL，对本端的单边账 通过SQL，对渠道/通道端的单边账 使用 SQL union 将 1 2 结果合并，并写入表 -- 对账结果表 CREATE TABLE IF NOT EXISTS dp.check_dp_buffer_record ( `biz_id` string comment &amp;#39;订单号&amp;#39;, `order_type` string comment &amp;#39;订单类型 0本端订单 1渠道订单&amp;#39;, `bill_date` int comment &amp;#39;对账日期&amp;#39;, `biz_type` int comment &amp;#39;业务类型&amp;#39;, `channel_code` int comment &amp;#39;渠道类型&amp;#39;, `amount` string comment &amp;#39;金额&amp;#39;, `merchant_no` string comment &amp;#39;商户号&amp;#39;, `sub_merchant_no` string comment &amp;#39;三方子商户号&amp;#39;, `trade_date` int comment &amp;#39;交易日期&amp;#39;, `create_time` string comment &amp;#39;创建时间&amp;#39;, `update_time` string comment &amp;#39;修改时间&amp;#39; ); -- 对账结果写入表 dp.</description>
    </item>
    
    <item>
      <title>0x01.支付系统概述</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/0x01.%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Sun, 25 Jun 2023 10:54:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/0x01.%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</guid>
      <description> 国际清算委员会定义: 所有涉及到资金转移的行为,都可视作支付行为,清算和结算属于支付过程中的特定环节。
清算发生在结算前,清算是为了提高结算标准化水平和效率。
支付系统：完成付款人向收款人转移货币债权的过程，包括交易过程、清算过程和结算过程。
支付(交易动作)：付款人通过金融机构提供的能力，向收款人交换支付工具(买受人付款给出卖人)。
清分(数据整理)：将全部交易数据，进行按照各个成员之间的往来方向、金额、手续费等进行分类、整理。（清算的数据准备阶段）
清算(汇总入账)：根据清分的结果进行汇总、轧差产生清算报表，填制清算的会计分录(根据轧差的净额)，并据此登记账务。
结算(资金划拨)：根据清分以及清算的数据，实现资金划拨过程。
对账(参与角色对账)： 一般在支付活动中，同银行内账户资金往来直接结算便可，而涉及不同银行之间账户资金往来的，则需先清算再结算。
名词-头寸 头寸：其实就是款项的意思，指的是银行当前所有可以运用的资金的总和，主要包括在央行的超额准备金、存放同业清算款项净额、银行存款以及现金等部分。 作为专业术语的头寸，也称为“头衬”，是一种市场约定，承诺买卖合约的最初部位，买进合约者是多头，处于盼涨部位；卖出合约者为空头，处于盼跌部位。 收多付少，叫做“多头寸”；收少付多，叫做“缺头寸”； 结算收付差额，叫做“轧头寸”；借款弥补差额，叫做“拆头寸”；想方设法调进款项，叫做“调头寸”； 暂时未用款项大于需用量，叫做“头寸松”；资金需求量大于闲置量，叫做“头寸紧”。 10个“袁大头”摞起来的高度，恰好是一寸，“头寸”这个词便是由此而来的
支付通道维度 维度 描述 示例 支付通道 提供支付服务的公司 微信、支付宝、京东、建行、易宝、汇付 支付产品 支付通道可用的产品 小程序支付、扫码、信用付、网银支付、app支付、银行卡、被扫 支付类型 线下支付、线上支付 - 案例1，用户想用扫码支付，可以使用微信、支付宝、京东的扫码支付付款给商户。 案例2，用户习惯用京东支付，可以使用京东任意产品付款给商户。 案例3，用户通过c端App(团油)，选择支付宝支付，可以使用易宝/汇付这种间连通道，走小程序支付。
场景todo 场景：小满在平安好车主渠道通过团油签约的油站，购买油品，并使用微信支付通道付款给好车主。 角色： 微信：收单机构(支付通道) 平安好车主：渠道 油站：售油商户 小满：个人用户 团油：平台 对账： 渠道对账：团油支付单与好车主支付单对账 商户对账：团油订单与油站订单对账 支付通道对账：团油支付单与微信账单对账 // https://www.zhihu.com/question/414081012 </description>
    </item>
    
    <item>
      <title>0x02.支付系统结构</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/0x02.%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 25 Jun 2023 10:54:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/0x02.%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</guid>
      <description>支付系统 清分系统 清算系统 结算系统 对账系统
graph LR server-gateway server-gateway1 A --&amp;gt; a --&amp;gt; C --&amp;gt; D 支付网关（内部网关，通道网关，渠道网关） 作用：支付系统流量出入口 签名验签 熔断限流 身份识别 API路由
引导路由 作用：根据支付应用、收款商户、订单额度等信息来决定提供给用户的支付方式列表。 - 收银台编排
支付交易路由 ？？？
支付交易核心系统 作用：支撑支付整体流程、状态流转。调用营销、通道等。类似支付前台。 支付单创建 状态推进 回告接收与回告业务系统
支付营销 作用：支付通道活动、业务渠道活动、自有满减活动支撑 - 支付券 - 积分奖励 - 通道活动 - 业务活动
支付通道（路由） 作用：根据用户选择的支付方式，结合费率、QOS等因素，选择最优支付通道 增量工作：新支付通道对接
支付通道管理 支付通道QPS 支付通道QOS 规则引擎配置 收款商户管理 日志管理 服务网关
支付中心 支付产品 支付营销 支付路由 账户服务 支付风控
通道路由
服务网关 支付商户管理 收银台引导路由 支付风控 支付通道管理 三方网关（通道、渠道）</description>
    </item>
    
    <item>
      <title>0x03.支付出海关注点</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/0x03.%E6%94%AF%E4%BB%98%E5%87%BA%E6%B5%B7%E5%85%B3%E6%B3%A8%E7%82%B9/</link>
      <pubDate>Sun, 25 Jun 2023 10:54:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/0x03.%E6%94%AF%E4%BB%98%E5%87%BA%E6%B5%B7%E5%85%B3%E6%B3%A8%E7%82%B9/</guid>
      <description>关注点 产品DTC出海模式（直面消费者：产品，价格，宣传，渠道） 支付： 1。钱怎么收，如何兼容包并多国不同的支付习惯，针对各地区支付习惯，选择支付产品与收单机构 可以根据合作业务，先针对业务发生国家进行调研。 2。成本问题，如何才能做到费率低（本土C端支付，以及B端跨境结算成本高） 3。合规、欺诈问题， 收款合规：需要明确各个国家支付监管要求。在能收钱的前提下保证「能提钱」。 结算合规：明确合法的结算方式&amp;hellip; 数据合规：保证不泄漏用户数据，安全性方面要有考虑，在数据传输和落地要有四要素等加密。 欺诈问题：跨国线上交易，欺诈手段则更加多样 钓鱼、爬虫、数据窃取、账户盗用要有相关措施。 4。
收钱：可先采用微信、支付宝海外付</description>
    </item>
    
    <item>
      <title>流动计算架构之就近路由</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97%E4%B9%8B%E5%B0%B1%E8%BF%91%E8%B7%AF%E7%94%B1/%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%B0%B1%E8%BF%91%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Sun, 25 Jun 2023 10:54:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97%E4%B9%8B%E5%B0%B1%E8%BF%91%E8%B7%AF%E7%94%B1/%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%B0%B1%E8%BF%91%E8%B7%AF%E7%94%B1/</guid>
      <description>就近路由 是在多机房环境下，尽可能降低服务调用过程的耗时，及服务资源的合理分配。 假设存在三个机房 A B C，订单服务调用支付服务 在理想状态下(所有服务负载一致)，A机房订单服务调用A机房的支付服务，资源损耗最低，网络延迟最低。 当同机房支付服务负载过高时，可以智能选择注册中心内的最优可用服务。 当同机房支付服务负载降低后，可再智能切回同机房的下游服务调用。
达到在下游服务负载不同、机房不同时，选择最优的服务进行请求。
那么，就会涉及到几个点：
获取某服务所有机房的实例负载 自定义服务调用权重及白名单 成本计算：主要针对资源调用成本 继承 AbstractLoadBalancerRule ，重写 public Server choose(Object key) ;
流动计算架构之就近路由</description>
    </item>
    
    <item>
      <title>企业BI平台预研课题</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E4%BC%81%E4%B8%9Abi%E5%B9%B3%E5%8F%B0%E9%A2%84%E7%A0%94%E8%AF%BE%E9%A2%98/</link>
      <pubDate>Sun, 25 Jun 2023 10:54:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E4%BC%81%E4%B8%9Abi%E5%B9%B3%E5%8F%B0%E9%A2%84%E7%A0%94%E8%AF%BE%E9%A2%98/</guid>
      <description>目标：服务于部门内部财务、业财、B端、企业应用等体系的趋势分析&amp;amp;经营分析&amp;amp;财经管报等展示
一期功能 项目搭建 Echarts集成 数据展示 二期功能 图表容器 前端自定义创建(Grafana) </description>
    </item>
    
    <item>
      <title>浅谈系统拆分思路</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E6%B5%85%E8%B0%88%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Sun, 25 Jun 2023 10:54:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E6%B5%85%E8%B0%88%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86%E6%80%9D%E8%B7%AF/</guid>
      <description>可以通过流量类型拆分：假设当前服务80%流量是用作基础信息查询，可以统计下接口，单独拉起一个提供查询的服务，连写/读库查数据。
连写库的原因是：可能有些接口无法接受主从延迟受的影响。这个酌情添加。
可以通过业务类型拆分：按照业务领域、边界，对请求量大的模块进行独立提供服务。</description>
    </item>
    
    <item>
      <title>生产环境OOM定位</title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E7%A8%B3%E5%AE%9A%E6%80%A7/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83oom%E5%AE%9A%E4%BD%8D/</link>
      <pubDate>Sun, 25 Jun 2023 10:54:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E7%B3%BB%E7%BB%9F%E7%A8%B3%E5%AE%9A%E6%80%A7/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83oom%E5%AE%9A%E4%BD%8D/</guid>
      <description> 工具：eclipse memory analyzer mac 配置 -startup ../Eclipse/plugins/org.eclipse.equinox.launcher_1.5.0.v20180512-1130.jar -data /Users/nenglianjituan/mat-log --launcher.library ../Eclipse/plugins/org.eclipse.equinox.launcher.cocoa.macosx.x86_64_1.1.700.v20180518-1200 -vm /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/bin -vmargs -Xmx4096m -Dorg.eclipse.swt.internal.carbon.smallFonts -XstartOnFirstThread 工具：IDEA Profiler com.czb.finance.report.dto.excel.NlFinanceVourcherInfoExportDTO 0xc49defa8 com.czb.finance.report.dto.excel.NlFinanceVourcherInfoExportDTO 0xc49df1c8
导入hprof文件 分析结果 右击类，在新选项卡中打开，可以观测每个对象信息 其中： 计数 表示对象有多少个 浅层 表示 保留 表示所有对象占用的空间
工具：JProfiler </description>
    </item>
    
    <item>
      <title>Dperf教程 - 1 - 介绍</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/dperf-%E5%8E%8B%E6%B5%8B/dperf-1-%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Wed, 21 Jun 2023 16:18:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/dperf-%E5%8E%8B%E6%B5%8B/dperf-1-%E4%BB%8B%E7%BB%8D/</guid>
      <description>https://www.oschina.net/p/dperf dperf 是一款由百度开源的超高性能的网络压力测试仪。
它使用了 DPDK 与用户态 TCP 协议栈技术，用一台 x86 服务器就可以制造巨大流量：数 10 亿并发连接，百 Gbps 吞吐，千万级 HTTP CPS，其性能远远超过商业测试仪。它还能够精确显示全链路的丢包数，能够帮助你准确找到被测设备性能瑕疵。
它既可以对用来对四层网关、交换机进行性能测试，也可用来测评 CPU 的网络报文处理能力。</description>
    </item>
    
    <item>
      <title>Arthas教程 - 1 - 安装与使用</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/arthas-%E7%BA%BF%E4%B8%8A%E7%9B%91%E6%8E%A7/arthas%E6%95%99%E7%A8%8B-1-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 20 Jun 2023 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/arthas-%E7%BA%BF%E4%B8%8A%E7%9B%91%E6%8E%A7/arthas%E6%95%99%E7%A8%8B-1-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description> java环境变量 # java mac export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_291.jdk/Contents/Home export CLASSPATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$JAVA_HOME/bin:$PATH 下载工具&amp;amp;启动 curl -O https://arthas.aliyun.com/arthas-boot.jar java -jar arthas-boot.jar
命令-描述-使用 dashboard - 显示进程、线程、服务信息 - dashboard jad - 显示代码 - jad package.ClassName watch - 显示方法返回值 - watch package.ClassName methodName returnObj </description>
    </item>
    
    <item>
      <title>Hugo教程 - 1 - 安装与部署</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/hugo-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93/hugo%E6%95%99%E7%A8%8B-1-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Tue, 20 Jun 2023 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/hugo-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93/hugo%E6%95%99%E7%A8%8B-1-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</guid>
      <description>安装brew $ ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
安装hugo $ brew install hugo
验证hugo which hugo /usr/local/bin/hugo ls -l $( which hugo ) lrwxr-xr-x 1 nenglianjituan admin 31 6 15 17:04 /usr/local/bin/hugo -&amp;gt; ../Cellar/hugo/0.113.0/bin/hugo hugo version hugo v0.113.0+extended darwin/amd64 BuildDate=unknown 使用hugo # 初始化一个项目(此时有结构，但是还不能使用) hugo new site hugoblog cd hugoblog # 创建文章 (content/post) hugo new post/document.md (真实目录创建在：content/post/document.md) # 下载一款皮肤 （安装皮肤 &amp;amp; 启动服务） cd hugoblog git clone https://github.com/spf13/hyde.git themes\hyde # 指定皮肤，启动服务 hugo server -D -t hyde --buildDrafts 扩展-皮肤下载地址 试看主题效果 1.</description>
    </item>
    
    <item>
      <title>Hugo教程 - 2 - 结构介绍</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/hugo-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93/hugo%E6%95%99%E7%A8%8B-2-%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Tue, 20 Jun 2023 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/hugo-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93/hugo%E6%95%99%E7%A8%8B-2-%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/</guid>
      <description>目录结构 . ├── archetypes (存放 front matter（前置数据）) ├── config.toml (全局配置文件) ├── content (存放网页的主要内容 Markdown 文件) ├── data (存放数据文件，通常是 json/yaml/toml 文件) ├── layouts (存放 HTML 模板) ├── static (存放静态文件，会被直接复制到 public 目录下) └── themes (存放现有的主题模板) content └── content ├── _index.md // https://example.com/ ├── about.md // https://example.com/about/ ├── posts | ├── _index.md // https://example.com/posts/ | ├── firstpost.md // https://example.com/posts/firstpost/ 模板(layouts、themes；layouts优先级高)语法 Hugo 使用 Go 语言的 html/template 库 作为模版引擎， 模板的标签为 {{}} , {{}} 中包含的内容叫“动作”</description>
    </item>
    
    <item>
      <title>Hugo教程 - 3 - 配置文件讲解</title>
      <link>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/hugo-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93/hugo%E6%95%99%E7%A8%8B-3-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 20 Jun 2023 16:45:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/hugo-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93/hugo%E6%95%99%E7%A8%8B-3-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid>
      <description>hugo.toml # 网站地址 baseURL = &amp;#39;https://huangruiying.github.io/&amp;#39; # 网站语言 languageCode = &amp;#34;en-us&amp;#34; # 网站title title = &amp;#39;hugo.toml-title&amp;#39; # 主题的名字，这个要跟myblog/themes 目录中的子目录的目录名一致 theme = &amp;#34;hyde&amp;#34; # home/category/tag 页面显示的文章数 (Default: 10) paginate = 2 # home/category/tag 页面用于摘要的字数 (Default: 70) summaryLength = 10 在模板中使用配置文件定义的数据 在sidebar.html内使用BaseURL 在模板内使用常量
常量在hugo.toml中定义： baseURL = &amp;#39;https://huangruiying.github.io/&amp;#39; 常量在模板使用： {{ .Site.BaseURL }} 在模板内使用数组，循环生成标题
数组在hugo.toml中定义： [[menu.sidebar]] name = &amp;#34;新浪&amp;#34; url = &amp;#34;https://www.sina.com&amp;#34; [[menu.sidebar]] name = &amp;#34;Github&amp;#34; url = &amp;#34;https://github.com&amp;#34; 数组在模板使用： {{ range .Site.Menus.sidebar -}} &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;{{.</description>
    </item>
    
    <item>
      <title>Support for Multiple Authors</title>
      <link>https://huangruiying.github.io/blog/multi-author/</link>
      <pubDate>Mon, 21 Feb 2022 16:04:06 -0500</pubDate>
      
      <guid>https://huangruiying.github.io/blog/multi-author/</guid>
      <description>Using Introduction, your site can feature multiple authors. Each post displays a byline &amp;ndash; the name of a post&amp;rsquo;s author &amp;ndash; if the author field is set in the post front matter. For example, here&amp;rsquo;s the front matter for this post:
--- title: &amp;#34;Support for Multiple Authors&amp;#34; date: 2022-02-20T02:04:06-05:00 tags: [&amp;#34;features&amp;#34;, &amp;#34;blog&amp;#34;] series: [&amp;#34;quickstart&amp;#34;] author: [&amp;#34;Hugo Contributors&amp;#34;] --- You can list one or more authors. For example, here&amp;rsquo;s a byline with two credits:</description>
    </item>
    
    <item>
      <title>Post with Images Example</title>
      <link>https://huangruiying.github.io/blog/coffee-ipsum/</link>
      <pubDate>Sun, 20 Feb 2022 12:04:16 -0500</pubDate>
      
      <guid>https://huangruiying.github.io/blog/coffee-ipsum/</guid>
      <description>Images can be added to posts using Markdown syntax:
![Sample image](workday.jpg) Which looks like this:
You can also use Hugo&amp;rsquo;s built-in figure shortcode. This lets you add a caption, and looks like this:
Black and white work day photo. Posts with images are great at capturing attention and showcasing your work. Why not try it today?</description>
    </item>
    
    <item>
      <title>**Start Here:** Configuration and Content</title>
      <link>https://huangruiying.github.io/blog/configuration/</link>
      <pubDate>Sat, 25 Jul 2020 02:04:06 -0500</pubDate>
      
      <guid>https://huangruiying.github.io/blog/configuration/</guid>
      <description>Here are some helpful tips for setting up this theme.
Configuration Most of what you&amp;rsquo;ll want to configure is demonstrated in the exampleSite config.toml. This is Hugo&amp;rsquo;s configuration file. You can copy the config.toml in the exampleSite/ to your site root get started.
Here are all the options included in the (live!) configuration file for this example site! Below are some specific things you might like to configure right away.</description>
    </item>
    
    <item>
      <title>Long Form Writing and Quotes</title>
      <link>https://huangruiying.github.io/blog/long-form-post/</link>
      <pubDate>Thu, 30 May 2019 20:18:53 -0500</pubDate>
      
      <guid>https://huangruiying.github.io/blog/long-form-post/</guid>
      <description>Prolific writes rejoice! Introduction beautifully renders long pages of writing and blocks of quoted text. Let the ipsum show you how.
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Cursus eget nunc scelerisque viverra. Quam vulputate dignissim suspendisse in est ante in nibh mauris. Pharetra magna ac placerat vestibulum lectus mauris. Eget lorem dolor sed viverra ipsum.
Elementum Nisi Quis eleifend quam adipiscing.</description>
    </item>
    
    <item>
      <title>Markdown Support</title>
      <link>https://huangruiying.github.io/blog/startup-ipsum/</link>
      <pubDate>Mon, 06 Nov 2017 12:04:06 -0500</pubDate>
      
      <guid>https://huangruiying.github.io/blog/startup-ipsum/</guid>
      <description>Introduction supports code blocks and syntax highlighting:
$ complicated techie code git bash ubuntu &amp;gt;&amp;gt;&amp;gt; return value init foo You can easily create tables using Markdown, with rows that support readability:
this is a table ! this is the 1st row this is the 2nd row this is the 3rd row edgy jo ke lands here this is the 5th row this is the 6th row Unordered lists render with high readabiltiy as well!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F/hive%E9%AB%98%E6%95%88%E5%AF%B9%E8%B4%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F/hive%E9%AB%98%E6%95%88%E5%AF%B9%E8%B4%A6/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%BB%BAsql%E6%A8%A1%E6%9D%BF%E5%AF%B9%E8%B4%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%BB%BAsql%E6%A8%A1%E6%9D%BF%E5%AF%B9%E8%B4%A6/</guid>
      <description>假设有以下场景 数据来源A在 A库 A1表 数据来源B在 第三方系统,可通过Http、Ftp等方式获取到
为了屏蔽差异，</description>
    </item>
    
    <item>
      <title></title>
      <link>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%BC%8Finterpreter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%BC%8Finterpreter/</guid>
      <description>Expression: 解析器对象 E1 imp Expression E2 imp Expression
Context: 待处理数据对象 List
解析器注册到上下文(待处理数据)中 ctx.reg(E1&amp;hellip;En)
执行解析器 for e in ctx.getExpressionList e.interpreter(ctx)</description>
    </item>
    
    <item>
      <title>Undated post</title>
      <link>https://huangruiying.github.io/blog/no-date/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huangruiying.github.io/blog/no-date/</guid>
      <description>I was born yesterday, tomorrow.</description>
    </item>
    
  </channel>
</rss>
