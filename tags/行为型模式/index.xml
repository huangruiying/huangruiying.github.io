<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>行为型模式 on 博客</title>
    <link>https://huangruiying.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content in 行为型模式 on 博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Wed, 23 Aug 2023 15:46:40 +0800</lastBuildDate><atom:link href="https://huangruiying.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>行为型模式-策略模式</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/todo%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/todo%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>核心思想 通过预先创建好多种行为，为不通场景提供服务
使用场景 对接多家支付通道时，每种支付通道对接方式是一种策略
实现思路 角色：Context、AbsStrategy、ApplyStrategy Context：根据传入条件，选择具体策略 AbsStrategy：定义策略功能与部分流程，主要包含接口和抽象类 ApplyStrategy：具体的应用策略</description>
    </item>
    
    <item>
      <title>行为型模式-观察者模式</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description> 核心思想 注册观察类到被观察的对象全局观察者列表中，让被观察对象知道有哪些类在观察它的变化，从而方便被观察者通知每个自身变化到观察者列表内。 使用场景 低耦合前提下，目标对象（Subject）的状态变化，观察者对象（Observers）都要接到通知。 实现思路 角色：Subject、Observer Subject：被观察的对象 Observer：观察者集合，Subject的动作要通知到这里。 Observers(List,维护Observer的集合) notifyEveryObserver(在有通知需求时(比如状态变更)，通知到每个Observer，遍历Observer并通知) </description>
    </item>
    
    <item>
      <title>行为型模式-命令模式</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>核心思想 是一种数据驱动的设计模式，它属于行为型模式。 请求以命令的形式包裹在对象中，并传给「调用对象」。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 使用场景 需要线预定义要执行的内容、步骤，后通过触发/定时执行时，可以使用 其他没太想好 实现思路 角色：Order、Stock、Broker Order：命令接口，定义标准的执行方法；用订单举例 execute(){} Stock：请求类，整合了所有可执行的命令；用店铺举例 ApplyStock：具体的命令对象；通过实现Order接口，扩展其执行功能；包装了Stock的每一个可执行的方法(命令)；用买卖举例 implement Order private Stock stock execute(){ stock.command(); } Broker：命令调用对象，维护Orders(ApplyStocks) public interface Order { void execute(); } public class Stock { private String name = &amp;#34;ABC&amp;#34;; private int quantity = 10; public void buy(){ System.out.println(&amp;#34;Stock [ Name: &amp;#34;+name+&amp;#34;,Quantity: &amp;#34; + quantity +&amp;#34; ] bought&amp;#34;); } public void sell(){ System.out.println(&amp;#34;Stock [ Name: &amp;#34;+name+&amp;#34;,Quantity: &amp;#34; + quantity +&amp;#34; ] sold&amp;#34;); } } public class BuyStock implements Order { private Stock abcStock; public BuyStock(Stock abcStock){ this.</description>
    </item>
    
    <item>
      <title>行为型模式-模版方法模式</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
      <description> 核心思想 一个抽象类公开定义了执行它的方法的方式/模板 使用场景 多态时，在抽象类中定义标准执行流程时 可以配合策略模式使用 实现思路 角色：AbsClass、 通过抽象类，明确主流程、主框架，将可能存在差异的地方进行抽象化，供子类自定义 class AbcTemplate&amp;lt;REQ,RES&amp;gt;{ RES do(REQ request){ &amp;quot;template define info &amp;quot;.sout special().sout } // 自定义 protected String special(); } </description>
    </item>
    
    <item>
      <title>行为型模式-事件监听</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/todo%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/todo%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/</guid>
      <description>核心思想【是 观察者模式 的一种实现】 生产监听事件到事件池， 监听事件池并获取事件，去执行。
使用场景
实现思路</description>
    </item>
    
    <item>
      <title>行为型模式-状态模式</title>
      <link>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 23 Aug 2023 15:46:40 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid>
      <description> 核心思想 对象的行为依赖于对象状态。通过状态的改变，而改变对象的行为 比如一个逻辑，if(status = 1) : case 1 ; if(status = 2) : case 2 ; 使用场景 离线计算收益时各步骤独立且状态明确; 捞取数据落地(新订单生成收益单、旧收益单)-status=1； 计算status=1的收益，并更新，记status=2； 捞取status=2的数据，通知到下游系统，成功记status=3，失败status=4； 实现思路 角色：Context、AbsState、ApplyState 离线计算收益时，1 捞取数据完成 3 计算收益完成 8 发布收益完成 ProfitState // 收益计算接口 ProfitCalculateContext#setState、getState // 记录任务执行进度 // 需要计算收益的数据捞取 ProfitExtractorState imp ProfitState doAction#执行当前状态需要的操作 // 收益计算 ProfitCalculatorState imp ProfitState // 发布计算好的收益数据 ProfitPublisherState imp ProfitState 调用流程 ctx = new ProfitCalculateContext() new ProfitExtractorState().doAction(ctx) // 开始1状态的执行。 new ProfitCalculatorState().doAction(ctx) // 开始3状态的执行。 new ProfitPublisherState().doAction(ctx) // 开始8状态的执行。 优点是什么？ 流程代码去耦合， 状态转换显示化，减少对象间依赖 状态类职责单一，易于扩展新状态 FAQ: 若有需求在ProfitExtractorState类中修改，该类怎么再进行设计？ </description>
    </item>
    
  </channel>
</rss>
