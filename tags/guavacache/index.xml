<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GuavaCache on 博客</title>
    <link>https://huangruiying.github.io/tags/guavacache/</link>
    <description>Recent content in GuavaCache on 博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 13 Jul 2023 14:01:20 +0800</lastBuildDate><atom:link href="https://huangruiying.github.io/tags/guavacache/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>优秀缓存框架必备的几个功能</title>
      <link>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/guavacache/0x01.%E4%BC%98%E7%A7%80%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E5%BF%85%E5%A4%87%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Thu, 13 Jul 2023 14:01:20 +0800</pubDate>
      
      <guid>https://huangruiying.github.io/%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/guavacache/0x01.%E4%BC%98%E7%A7%80%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E5%BF%85%E5%A4%87%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8A%9F%E8%83%BD/</guid>
      <description>缓存的三种模型：旁路型、穿透型、异步型 旁路型：即先去缓存中尝试查询获取数据，如果获取不到则会从数据库中进行查询并加入到缓存中； 穿透型：查询不到缓存时，自动取数据源的数据，并放入缓存。缓存框架封装的逻辑，不用人工再实现。
多种缓存过期策略 1. 基于创建时间过期 2. 基于访问时间过期
多种缓存载体 jvm、堆外内存、内存型数据库、缓存文件
支持缓存容量上限设置 针对高效的jvm缓存，内存有限，所以要支持控制住缓存占用的空间。 可以通过条数控制 可以通过容量控制
支持自定义缓存淘汰算法 即然内存有限，想要最优使用缓存，那必然要将实际业务场景与缓存淘汰策略结合，故需支持灵活淘汰算法。 可以手动指定缓存淘汰算法 可以动态调整缓存淘汰算法
支持缓存不存在时,自动更新缓存 （穿透型缓存、回源查询） 当查询缓存，发现结果为空(不存在或过期),可以通过预先写好的逻辑，执行查询数据源，获取结果并进行缓存。</description>
    </item>
    
  </channel>
</rss>
