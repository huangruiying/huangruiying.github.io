import{_ as s,c as e,o as n,a1 as t}from"./chunks/framework.CPsxJxQM.js";const u=JSON.parse('{"title":"问题","description":"","frontmatter":{},"headers":[],"relativePath":"算法整理/算法题型/判环算法｜寻找重复数.md","filePath":"算法整理/算法题型/判环算法｜寻找重复数.md"}'),i={name:"算法整理/算法题型/判环算法｜寻找重复数.md"};function l(p,a,o,c,d,h){return n(),e("div",null,a[0]||(a[0]=[t('<h1 id="问题" tabindex="-1">问题 <a class="header-anchor" href="#问题" aria-label="Permalink to &quot;问题&quot;">​</a></h1><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>数组nums长度为n+1，其中nums[i]的范围为[1,n]。可知至少存在一个重复的整数(因为把1-n铺平也装不满长度为n+1的数组)。</span></span>\n<span class="line"><span>假设只有一个数字重复，请找到。</span></span></code></pre></div><h2 id="分析" tabindex="-1">分析 <a class="header-anchor" href="#分析" aria-label="Permalink to &quot;分析&quot;">​</a></h2><h3 id="为什么数组构成一个带环链表" tabindex="-1">为什么数组构成一个带环链表？ <a class="header-anchor" href="#为什么数组构成一个带环链表" aria-label="Permalink to &quot;为什么数组构成一个带环链表？&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>nums[i]的值范围都在数组长度内，且存在重复数，所以看作环。</span></span></code></pre></div><h3 id="为什么不重复数组不会回到某个已访问的索引" tabindex="-1">为什么不重复数组不会回到某个已访问的索引？ <a class="header-anchor" href="#为什么不重复数组不会回到某个已访问的索引" aria-label="Permalink to &quot;为什么不重复数组不会回到某个已访问的索引？&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>值不重复，故每个下标只访问一次。</span></span></code></pre></div><h3 id="为什么不重复的数组无法形成环" tabindex="-1">为什么不重复的数组无法形成环 <a class="header-anchor" href="#为什么不重复的数组无法形成环" aria-label="Permalink to &quot;为什么不重复的数组无法形成环&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>不重复数组，值从1起始，那么最大值最小是n，但数组最大下标为n-1，所以越界。</span></span></code></pre></div><h3 id="为什么-slow-和-fast-一定会相遇" tabindex="-1">为什么 slow 和 fast 一定会相遇？ <a class="header-anchor" href="#为什么-slow-和-fast-一定会相遇" aria-label="Permalink to &quot;为什么 slow 和 fast 一定会相遇？&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>类似「龟兔赛跑」，快指针每次走两步，慢指针每次走一步，在有环的情况下，快指针一定会进入环并在某个时刻追上慢指针。</span></span></code></pre></div><h3 id="为什么重新设定-fast-nums-0-然后同步走一定会在入口相遇" tabindex="-1">为什么重新设定 fast = nums[0]，然后同步走一定会在入口相遇？ <a class="header-anchor" href="#为什么重新设定-fast-nums-0-然后同步走一定会在入口相遇" aria-label="Permalink to &quot;为什么重新设定 fast = nums[0]，然后同步走一定会在入口相遇？&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>设 环的入口 为 `E`，从起点到 `E` 需要走 `a` 步，从 `E` 到相遇点需要 `b` 步，环的长度为 `c`。</span></span>\n<span class="line"><span>由于 `fast` 速度是 `slow` 的 2 倍，最终 `fast` 走的步数 `a + b + kc`（`k` 是整数），慢指针走 `a + b`，所以：</span></span>\n<span class="line"><span>  ```a + b + kc = 2(a + b)```</span></span>\n<span class="line"><span>  化简得：</span></span>\n<span class="line"><span>  ```a + b = kc```</span></span>\n<span class="line"><span>这意味着：从相遇点开始，继续走 `a` 步就能回到 `E`，而 `fast` 也从 `0` 开始走 `a` 步，因此两者必定在 `E` 相遇！</span></span></code></pre></div><h2 id="实现" tabindex="-1">实现 <a class="header-anchor" href="#实现" aria-label="Permalink to &quot;实现&quot;">​</a></h2><p><a href="./../算法理论/判环算法｜Floyd｜双指针判环.html">判环算法｜floyd｜双指针判环</a></p>',15)]))}const b=s(i,[["render",l]]);export{u as __pageData,b as default};
