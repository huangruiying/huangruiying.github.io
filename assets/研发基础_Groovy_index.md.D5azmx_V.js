import{_ as o,c as r,o as a,a1 as d}from"./chunks/framework.CPsxJxQM.js";const c=JSON.parse('{"title":"Java Groovy性能差异","description":"","frontmatter":{},"headers":[],"relativePath":"研发基础/Groovy/index.md","filePath":"研发基础/Groovy/index.md"}'),e={name:"研发基础/Groovy/index.md"};function s(l,t,n,v,h,i){return a(),r("div",null,t[0]||(t[0]=[d('<h1 id="java-groovy性能差异" tabindex="-1">Java Groovy性能差异 <a class="header-anchor" href="#java-groovy性能差异" aria-label="Permalink to &quot;Java Groovy性能差异&quot;">​</a></h1><p>Groovy 的性能劣势主要体现在 CPU 密集型 场景中，比如复杂的计算逻辑或频繁方法调用；一旦涉及 IO 操作（如网络请求、数据库访问等），由于 IO 等待占据主导，两者的执行耗时基本一致，Groovy 的动态开销就显得不那么重要了。</p><h2 id="执行groovy脚本的几种方式" tabindex="-1">执行Groovy脚本的几种方式 <a class="header-anchor" href="#执行groovy脚本的几种方式" aria-label="Permalink to &quot;执行Groovy脚本的几种方式&quot;">​</a></h2><p>GroovyShell、GroovyClassLoader</p><h2 id="groovyshell-和-groovyclassloader-核心区别" tabindex="-1">GroovyShell 和 GroovyClassLoader 核心区别 <a class="header-anchor" href="#groovyshell-和-groovyclassloader-核心区别" aria-label="Permalink to &quot;GroovyShell 和 GroovyClassLoader 核心区别&quot;">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th>GroovyShell</th><th>GroovyClassLoader</th></tr></thead><tbody><tr><td><strong>执行方式</strong></td><td>解释执行（即时执行）</td><td>编译成类再执行</td></tr><tr><td><strong>返回类型</strong></td><td><code>Object</code>（脚本执行结果）</td><td><code>Class</code>（可实例化执行）</td></tr><tr><td><strong>适合场景</strong></td><td>动态脚本求值、一次性执行</td><td>动态类加载、反复使用、面向对象脚本</td></tr><tr><td><strong>支持绑定变量</strong></td><td>✅ 支持 Binding 变量绑定</td><td>❌ 不直接支持（需手动处理）</td></tr><tr><td><strong>缓存机制</strong></td><td>无编译缓存，每次重新解析</td><td>编译后类缓存，可重用</td></tr><tr><td><strong>性能</strong></td><td>相对较慢（每次解释执行）</td><td>更快（已编译成字节码）</td></tr></tbody></table>',6)]))}const g=o(e,[["render",s]]);export{c as __pageData,g as default};
