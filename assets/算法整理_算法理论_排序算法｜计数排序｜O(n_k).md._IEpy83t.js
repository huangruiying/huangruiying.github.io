import{_ as e,c as t,o as i,a1 as l}from"./chunks/framework.BMsMDqYY.js";const u=JSON.parse('{"title":"计数排序","description":"","frontmatter":{},"headers":[],"relativePath":"算法整理/算法理论/排序算法｜计数排序｜O(n+k).md","filePath":"算法整理/算法理论/排序算法｜计数排序｜O(n+k).md"}'),n={name:"算法整理/算法理论/排序算法｜计数排序｜O(n+k).md"};function r(s,a,o,_,d,c){return i(),t("div",null,a[0]||(a[0]=[l('<h1 id="计数排序" tabindex="-1">计数排序 <a class="header-anchor" href="#计数排序" aria-label="Permalink to &quot;计数排序&quot;">​</a></h1><h2 id="算法原理" tabindex="-1">算法原理 <a class="header-anchor" href="#算法原理" aria-label="Permalink to &quot;算法原理&quot;">​</a></h2><ul><li>找到数组最大值 maxNum，创建计数数组，大小为最大值+1，初始化为0 arr = new int[maxNum + 1]{}</li><li>统计每个元素出现的次数，存入计数数组 arr[num] ++</li><li>根据统计结果将元素放回正确的位置 <ul><li>直接遍历计数数组，利用索引与个数进行恢复 (相同的数字位置不一样，不稳定排序)</li><li>反向填充 (稳定)</li></ul></li></ul><h2 id="代码示例" tabindex="-1">代码示例 <a class="header-anchor" href="#代码示例" aria-label="Permalink to &quot;代码示例&quot;">​</a></h2><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div>',5)]))}const p=e(n,[["render",r]]);export{u as __pageData,p as default};
