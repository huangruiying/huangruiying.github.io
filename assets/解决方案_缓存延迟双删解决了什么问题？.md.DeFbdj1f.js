import{_ as l,c as e,o as i,a1 as o}from"./chunks/framework.CPsxJxQM.js";const b=JSON.parse('{"title":"RT,缓存延时双删","description":"","frontmatter":{},"headers":[],"relativePath":"解决方案/缓存延迟双删解决了什么问题？.md","filePath":"解决方案/缓存延迟双删解决了什么问题？.md"}'),t={name:"解决方案/缓存延迟双删解决了什么问题？.md"};function r(d,a,n,h,_,s){return i(),e("div",null,a[0]||(a[0]=[o('<h1 id="rt-缓存延时双删" tabindex="-1">RT,缓存延时双删 <a class="header-anchor" href="#rt-缓存延时双删" aria-label="Permalink to &quot;RT,缓存延时双删&quot;">​</a></h1><h2 id="什么是缓存延时双删" tabindex="-1">什么是缓存延时双删 <a class="header-anchor" href="#什么是缓存延时双删" aria-label="Permalink to &quot;什么是缓存延时双删&quot;">​</a></h2><p>简单来说，写数据时先删缓存、再写db、再删缓存。</p><h2 id="解决了什么问题" tabindex="-1">解决了什么问题 <a class="header-anchor" href="#解决了什么问题" aria-label="Permalink to &quot;解决了什么问题&quot;">​</a></h2><p>那现在问题来了，这样的话我直接写db&amp;删缓存不就行了，为什么还要先删一次缓存呢？</p><blockquote><p>延时双删是为了解决 <b>并发穿插写</b> 时的缓存不一致时间过长问题，它采用先删一次的方式，让部分场景（删除缓存后没查询请求，直至更新db完毕后才有查询进来）达到数据库与缓存内容一致。 它只是通过拆分缓存不一致区间，降低了缓存不一致的概率（某些场景），并不能完全解决缓存不一致的问题。</p></blockquote><h2 id="先写在删-与-延时双删-场景对比" tabindex="-1">“先写在删” 与 “延时双删” 场景对比 <a class="header-anchor" href="#先写在删-与-延时双删-场景对比" aria-label="Permalink to &quot;“先写在删” 与 “延时双删” 场景对比&quot;">​</a></h2><h3 id="先写在删-场景-更新数据库-→-删缓存" tabindex="-1">“先写在删”场景（更新数据库 → 删缓存） <a class="header-anchor" href="#先写在删-场景-更新数据库-→-删缓存" aria-label="Permalink to &quot;“先写在删”场景（更新数据库 → 删缓存）&quot;">​</a></h3><ol><li>线程 B 查询缓存，命中缓存的旧值“old” （此时数据库也是old，缓存与数据库一致）</li><li>线程 A 更新数据库，改成 “new”，（至此以后，缓存与数据库开始不一致，缓存内是old，但是数据库是new）</li><li>线程 A 删除缓存，至此以后，缓存与数据库一致（后续线程会查询到db的新值new，并写入缓存。） 数据不一致窗口：步骤(2,3)</li></ol><h3 id="延时双删-场景-更新数据库-→-删缓存" tabindex="-1">“延时双删”场景（更新数据库 → 删缓存） <a class="header-anchor" href="#延时双删-场景-更新数据库-→-删缓存" aria-label="Permalink to &quot;“延时双删”场景（更新数据库 → 删缓存）&quot;">​</a></h3><ol><li>删除缓存</li><li>数据库更新完成（新值new写入db）</li><li>第二次删除缓存（旧值二次清除）</li></ol><p>数据不一致窗口：步骤(2,3)</p><h4 id="首次删除缓存后-更新数据空完成前-无查询请求。" tabindex="-1">首次删除缓存后，更新数据空完成前，无查询请求。 <a class="header-anchor" href="#首次删除缓存后-更新数据空完成前-无查询请求。" aria-label="Permalink to &quot;首次删除缓存后，更新数据空完成前，无查询请求。&quot;">​</a></h4><ol><li>删除缓存（old）</li><li>数据库更新完成（新值new写入db）</li><li>线程 B 查询请求，此时查询到新数据（new）写入缓存。</li><li>第二次删除缓存（此时清理的是新值new，不影响）</li></ol><p>数据不一致窗口：无。步骤1、2没有请求进入，导致更新前删除的缓存一直没被旧数据覆盖。</p><h4 id="首次删除缓存后-更新数据空完成前-存在查询请求。" tabindex="-1">首次删除缓存后，更新数据空完成前，存在查询请求。 <a class="header-anchor" href="#首次删除缓存后-更新数据空完成前-存在查询请求。" aria-label="Permalink to &quot;首次删除缓存后，更新数据空完成前，存在查询请求。&quot;">​</a></h4><ol><li>删除缓存（old）</li><li>[查询请求] 线程 B 查询请求，此时查询到旧数据（old）写入缓存。</li><li>数据库更新完成（新值new写入db），（至此以后，缓存与数据库开始不一致，缓存内是old，但是数据库是new）</li><li>第二次删除缓存（此时清理的是旧值old），至此以后，缓存与数据库一致</li></ol><p>数据不一致窗口：步骤(3,4)</p>',18)]))}const p=l(t,[["render",r]]);export{b as __pageData,p as default};
