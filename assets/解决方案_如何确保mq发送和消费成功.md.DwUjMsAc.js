import{_ as l,c as a,o as e,a1 as i}from"./chunks/framework.CPsxJxQM.js";const m=JSON.parse('{"title":"如何确保mq发送和消费成功?","description":"","frontmatter":{},"headers":[],"relativePath":"解决方案/如何确保mq发送和消费成功.md","filePath":"解决方案/如何确保mq发送和消费成功.md"}'),o={name:"解决方案/如何确保mq发送和消费成功.md"};function t(n,r,s,u,h,d){return e(),a("div",null,r[0]||(r[0]=[i('<h1 id="如何确保mq发送和消费成功" tabindex="-1">如何确保mq发送和消费成功? <a class="header-anchor" href="#如何确保mq发送和消费成功" aria-label="Permalink to &quot;如何确保mq发送和消费成功?&quot;">​</a></h1><p>所有的mq我们都暂且看为三个角色：生产(Producer)方、消费(Consumer)方、MQ核心系统(Broker / Server)<br><strong>那我们明确下他们的职责</strong></p><ol><li><strong>Producer</strong>：发送消息到MQ核心</li><li><strong>Broker</strong>：接收消息并持久化（若开启），路由消息到正确的消费者，确保可靠性（如消息确认、重试机制、死信队列等）。</li><li><strong>Consumer</strong>：从MQ接收消息。Consumer主动拉取(Kafka、RocketMQ)、Broker主动推送(RabbitMQ)</li></ol><p><strong>此时引入了几个概念</strong></p><ul><li><strong>持久化</strong>：数据写入磁盘，防止宕机丢失。确保mq重启后消息仍存在。</li><li><strong>消息确认</strong>：消费者在成功处理消息后，向MQ发送一个「已处理」的确认信号。</li><li><strong>重试机制</strong>：消费失败时，立即重试、延迟重试、死信队列(重试无果后)</li><li><strong>死信队列</strong>：无法被成功消费的消息，转移到的特殊队列。触发条件如下： <ul><li>消息被重试多次仍失败</li><li>消费者拒绝处理</li><li>消息过期</li></ul></li></ul><h3 id="faq" tabindex="-1">FAQ <a class="header-anchor" href="#faq" aria-label="Permalink to &quot;FAQ&quot;">​</a></h3><ul><li>消费者如何消费消息。 <ul><li>大致分为MQ再投递(让消息允许再拉取)、MQ推送、消费者再拉取</li></ul></li><li>消费者拉取的模式，没有消息确认，mq会重试投递还是消费者重试拉取？ <ul><li>Kafka，提交offset，方便下次消费者拉取时知道从哪开始拉数据。</li><li>RocketMQ，客户端确认，方便Broker决定是否再次投递（此处的投递为：消息放入队列，供Consumer再次拉取）。</li></ul></li><li><strong>消费者拒绝处理消息</strong>是一个什么操作，与<strong>消息被重试多次仍失败</strong>有什么区别？ <ul><li>拒绝处理：消费者拿到消息后发现格式、业务场景等非法，直接拒绝。不重试。</li><li>多次消费失败：消息本身符合要求，但受网络异常、消费者逻辑出错导致的消费失败。会重试。</li></ul></li><li>消费者失败会跟主动拒绝在消费者代码中，给broker反馈的代码区别是什么？ <ul><li>消费成功：return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</li><li>想重试：return ConsumeConcurrentlyStatus.RECONSUME_LATER;</li><li>拒绝处理：无显式拒绝，可业务实现。</li></ul></li></ul><h2 id="如何保证生产者发送成功" tabindex="-1">如何保证生产者发送成功 <a class="header-anchor" href="#如何保证生产者发送成功" aria-label="Permalink to &quot;如何保证生产者发送成功&quot;">​</a></h2><ul><li>同步发送：生产者线程同步等待Broker返回的ack（可定义ack的级别，让所有副本都确认）</li><li>异步+回调：生产者异步发送，并设置回调监听，监听中处理失败的逻辑</li><li>失败重发：生产者端自动重试发送失败消息</li></ul><h2 id="避免消息丢失" tabindex="-1">避免消息丢失 <a class="header-anchor" href="#避免消息丢失" aria-label="Permalink to &quot;避免消息丢失&quot;">​</a></h2><p>开启 Broker 持久化，保证磁盘写入</p><h2 id="避免重复消息" tabindex="-1">避免重复消息 <a class="header-anchor" href="#避免重复消息" aria-label="Permalink to &quot;避免重复消息&quot;">​</a></h2><p>确保消息id唯一，Broker去重</p><h2 id="保证消息与本地事务原子性" tabindex="-1">保证消息与本地事务原子性 <a class="header-anchor" href="#保证消息与本地事务原子性" aria-label="Permalink to &quot;保证消息与本地事务原子性&quot;">​</a></h2><p>事务提交后发送消息，失败回滚</p><h2 id="如何保证消费者消费成功" tabindex="-1">如何保证消费者消费成功 <a class="header-anchor" href="#如何保证消费者消费成功" aria-label="Permalink to &quot;如何保证消费者消费成功&quot;">​</a></h2><p>记录消息log到数据库，消息id做幂等</p>',17)]))}const _=l(o,[["render",t]]);export{m as __pageData,_ as default};
