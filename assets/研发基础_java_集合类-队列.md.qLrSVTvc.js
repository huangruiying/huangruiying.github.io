import{_ as d,c as e,o,a1 as r}from"./chunks/framework.BMsMDqYY.js";const h=JSON.parse('{"title":"JDK8的队列划分","description":"","frontmatter":{},"headers":[],"relativePath":"研发基础/java/集合类-队列.md","filePath":"研发基础/java/集合类-队列.md"}'),n={name:"研发基础/java/集合类-队列.md"};function c(s,t,g,a,l,i){return o(),e("div",null,t[0]||(t[0]=[r('<h1 id="jdk8的队列划分" tabindex="-1">JDK8的队列划分 <a class="header-anchor" href="#jdk8的队列划分" aria-label="Permalink to &quot;JDK8的队列划分&quot;">​</a></h1><p>JDK8 中的队列主要分为 <strong>阻塞队列</strong>、<strong>非阻塞队列</strong> 和 <strong>双端队列</strong>，按不同场景可选用合适的数据结构。</p><h2 id="_1-非阻塞队列-普通队列-非线程安全" tabindex="-1">1. 非阻塞队列（普通队列，非线程安全） <a class="header-anchor" href="#_1-非阻塞队列-普通队列-非线程安全" aria-label="Permalink to &quot;1. 非阻塞队列（普通队列，非线程安全）&quot;">​</a></h2><ul><li><strong><code>ArrayDeque&lt;E&gt;</code></strong>：基于<strong>数组</strong>的双端队列，<strong>无界</strong>，支持<strong>栈和队列</strong>操作，替代 <code>Stack</code> 和 <code>LinkedList</code>。</li><li><strong><code>PriorityQueue&lt;E&gt;</code></strong>：<strong>基于堆</strong>（默认<strong>小根堆</strong>），元素按优先级排序，不支持 <code>null</code>，非线程安全。</li><li><strong><code>LinkedList&lt;E&gt;</code></strong>：<strong>基于链表</strong>，支持<strong>FIFO 队列</strong>和<strong>双端队列</strong>操作。</li></ul><h2 id="_2-阻塞队列-线程安全" tabindex="-1">2. 阻塞队列（线程安全） <a class="header-anchor" href="#_2-阻塞队列-线程安全" aria-label="Permalink to &quot;2. 阻塞队列（线程安全）&quot;">​</a></h2><ul><li><strong><code>ArrayBlockingQueue&lt;E&gt;</code></strong>：<strong>基于数组</strong>的<strong>有界</strong>阻塞队列，FIFO 规则。</li><li><strong><code>LinkedBlockingQueue&lt;E&gt;</code></strong>：<strong>基于链表</strong>的阻塞队列，<strong>默认 Integer.MAX_VALUE</strong> 容量。</li><li><strong><code>PriorityBlockingQueue&lt;E&gt;</code></strong>：<strong>基于堆</strong>的<strong>无界</strong>优先级队列，类似 <code>PriorityQueue</code>，但<strong>线程安全</strong>。</li><li><strong><code>DelayQueue&lt;E&gt;</code></strong>：支持<strong>定时</strong>出队，<strong>元素需实现 <code>Delayed</code> 接口</strong>，用于<strong>定时任务</strong>。</li><li><strong><code>SynchronousQueue&lt;E&gt;</code></strong>：容量 <strong>=0</strong>，生产者放入后必须等待消费者取出，<strong>无缓冲</strong>。</li><li><strong><code>LinkedTransferQueue&lt;E&gt;</code></strong>：基于链表的<strong>无界</strong>队列，支持 <code>tryTransfer</code> 方法，可用于<strong>生产者直接交付给消费者</strong>。</li></ul><h2 id="_3-并发队列-无锁-高并发-线程安全" tabindex="-1">3. 并发队列（无锁/高并发/线程安全） <a class="header-anchor" href="#_3-并发队列-无锁-高并发-线程安全" aria-label="Permalink to &quot;3. 并发队列（无锁/高并发/线程安全）&quot;">​</a></h2><ul><li><strong><code>ConcurrentLinkedQueue&lt;E&gt;</code></strong>：<strong>基于 CAS</strong> 的<strong>无界</strong>非阻塞<strong>队列</strong>，高并发下性能优于 <code>LinkedBlockingQueue</code>。</li><li><strong><code>ConcurrentLinkedDeque&lt;E&gt;</code></strong>：<strong>双端</strong>无锁队列，类似 <code>ConcurrentLinkedQueue</code>，支持 <code>Deque</code> 操作。</li></ul><h2 id="_4-双端队列-deque" tabindex="-1">4. 双端队列（Deque） <a class="header-anchor" href="#_4-双端队列-deque" aria-label="Permalink to &quot;4. 双端队列（Deque）&quot;">​</a></h2><ul><li><strong><code>ArrayDeque&lt;E&gt;</code></strong>：<strong>无界</strong>数组双端队列（见上）。</li><li><strong><code>LinkedBlockingDeque&lt;E&gt;</code></strong>：<strong>链表实现的有界阻塞</strong>双端队列，支持 <code>putFirst/putLast</code>。</li><li><strong><code>ConcurrentLinkedDeque&lt;E&gt;</code></strong>：<strong>无锁 线程安全</strong>双端队列（见上）。</li></ul><h2 id="选择建议" tabindex="-1">选择建议 <a class="header-anchor" href="#选择建议" aria-label="Permalink to &quot;选择建议&quot;">​</a></h2><table tabindex="0"><thead><tr><th><strong>用途</strong></th><th><strong>推荐队列</strong></th></tr></thead><tbody><tr><td>高并发无锁队列</td><td><code>ConcurrentLinkedQueue</code></td></tr><tr><td>有界阻塞队列</td><td><code>ArrayBlockingQueue</code></td></tr><tr><td>无界阻塞队列</td><td><code>LinkedBlockingQueue</code></td></tr><tr><td>优先级队列</td><td><code>PriorityQueue</code>（单线程），<code>PriorityBlockingQueue</code>（多线程）</td></tr><tr><td>生产者-消费者</td><td><code>LinkedBlockingQueue</code> / <code>SynchronousQueue</code></td></tr><tr><td>定时任务队列</td><td><code>DelayQueue</code></td></tr><tr><td>低延迟高吞吐</td><td><code>LinkedTransferQueue</code></td></tr></tbody></table><h1 id="基础队列操作" tabindex="-1">基础队列操作 <a class="header-anchor" href="#基础队列操作" aria-label="Permalink to &quot;基础队列操作&quot;">​</a></h1><h2 id="_1-单向队列" tabindex="-1">1.单向队列 <a class="header-anchor" href="#_1-单向队列" aria-label="Permalink to &quot;1.单向队列&quot;">​</a></h2><table tabindex="0"><thead><tr><th><strong>队列</strong></th><th><strong>方法名</strong></th><th><strong>操作描述</strong></th><th><strong>无数据时行为</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>Queue 接口（单向队列）</strong></td><td><code>offer(E e)</code></td><td>添加元素</td><td>返回 <code>false</code></td><td>推荐使用</td></tr><tr><td></td><td><code>add(E e)</code></td><td>添加元素</td><td>抛 <code>IllegalStateException</code></td><td>容量受限时异常</td></tr><tr><td></td><td><code>poll()</code></td><td>取出并删除头部元素</td><td>返回 <code>null</code></td><td>推荐使用</td></tr><tr><td></td><td><code>remove()</code></td><td>取出并删除头部元素</td><td>抛 <code>NoSuchElementException</code></td><td>容量受限时异常</td></tr><tr><td></td><td><code>peek()</code></td><td>获取头部元素但不删除</td><td>返回 <code>null</code></td><td>推荐使用</td></tr><tr><td></td><td><code>element()</code></td><td>获取头部元素但不删除</td><td>抛 <code>NoSuchElementException</code></td><td>容量受限时异常</td></tr></tbody></table><h2 id="_2-双端队列" tabindex="-1">2.双端队列 <a class="header-anchor" href="#_2-双端队列" aria-label="Permalink to &quot;2.双端队列&quot;">​</a></h2><table tabindex="0"><thead><tr><th><strong>队列</strong></th><th><strong>方法名</strong></th><th><strong>操作描述</strong></th><th><strong>无数据时行为</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>Deque 接口（双端队列）</strong></td><td><code>offerFirst(E e)</code></td><td>头部插入</td><td>返回 <code>false</code></td><td>推荐使用</td></tr><tr><td></td><td><code>offerLast(E e)</code></td><td>尾部插入</td><td>返回 <code>false</code></td><td>推荐使用</td></tr><tr><td></td><td><code>addFirst(E e)</code></td><td>头部插入</td><td>抛 <code>IllegalStateException</code></td><td>容量受限时异常</td></tr><tr><td></td><td><code>addLast(E e)</code></td><td>尾部插入</td><td>抛 <code>IllegalStateException</code></td><td>容量受限时异常</td></tr><tr><td></td><td><code>pollFirst()</code></td><td>取出并删除头部元素</td><td>返回 <code>null</code></td><td>推荐使用</td></tr><tr><td></td><td><code>pollLast()</code></td><td>取出并删除尾部元素</td><td>返回 <code>null</code></td><td>推荐使用</td></tr><tr><td></td><td><code>removeFirst()</code></td><td>取出并删除头部元素</td><td>抛 <code>NoSuchElementException</code></td><td>容量受限时异常</td></tr><tr><td></td><td><code>removeLast()</code></td><td>取出并删除尾部元素</td><td>抛 <code>NoSuchElementException</code></td><td>容量受限时异常</td></tr><tr><td></td><td><code>peekFirst()</code></td><td>获取头部元素但不删除</td><td>返回 <code>null</code></td><td>推荐使用</td></tr><tr><td></td><td><code>peekLast()</code></td><td>获取尾部元素但不删除</td><td>返回 <code>null</code></td><td>推荐使用</td></tr><tr><td></td><td><code>getFirst()</code></td><td>获取头部元素但不删除</td><td>抛 <code>NoSuchElementException</code></td><td>容量受限时异常</td></tr><tr><td></td><td><code>getLast()</code></td><td>获取尾部元素但不删除</td><td>抛 <code>NoSuchElementException</code></td><td>容量受限时异常</td></tr></tbody></table><h2 id="_3-阻塞队列" tabindex="-1">3.阻塞队列 <a class="header-anchor" href="#_3-阻塞队列" aria-label="Permalink to &quot;3.阻塞队列&quot;">​</a></h2><table tabindex="0"><thead><tr><th><strong>阻塞队列（BlockingQueue）</strong></th><th><strong>方法名</strong></th><th><strong>操作描述</strong></th><th><strong>无数据时行为</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><code>put(E e)</code></td><td>添加元素</td><td><strong>阻塞</strong></td><td>适用于生产者-消费者模型</td><td></td></tr><tr><td><code>take()</code></td><td>取出并删除头部元素</td><td><strong>阻塞</strong></td><td>适用于生产者-消费者模型</td><td></td></tr><tr><td><code>offer(E e, long timeout, TimeUnit unit)</code></td><td>超时添加元素</td><td><strong>超时返回 <code>false</code></strong></td><td>推荐用于有界队列</td><td></td></tr><tr><td><code>poll(long timeout, TimeUnit unit)</code></td><td>超时获取并删除头部元素</td><td><strong>超时返回 <code>null</code></strong></td><td>推荐用于有界队列</td><td></td></tr></tbody></table><h2 id="_4-主要队列实现" tabindex="-1">4.主要队列实现 <a class="header-anchor" href="#_4-主要队列实现" aria-label="Permalink to &quot;4.主要队列实现&quot;">​</a></h2><table tabindex="0"><thead><tr><th><strong>队列类型</strong></th><th><strong>特点</strong></th><th><strong>线程安全</strong></th></tr></thead><tbody><tr><td><code>ArrayDeque</code></td><td><strong>双端队列</strong>，基于 <strong>数组</strong>，无锁</td><td>❌</td></tr><tr><td><code>LinkedList</code></td><td><strong>双端队列</strong>，基于 <strong>链表</strong>，无锁</td><td>❌</td></tr><tr><td><code>PriorityQueue</code></td><td><strong>优先队列</strong>，按 <strong>自然排序或自定义排序</strong> 出队</td><td>❌</td></tr><tr><td><code>ConcurrentLinkedQueue</code></td><td><strong>无锁队列（FIFO）</strong>，基于 <strong>CAS</strong>，无界</td><td>✅</td></tr><tr><td><code>ConcurrentLinkedDeque</code></td><td><strong>无锁双端队列</strong>，基于 <strong>CAS</strong>，无界</td><td>✅</td></tr><tr><td><code>ArrayBlockingQueue</code></td><td><strong>数组实现，有界，阻塞</strong></td><td>✅</td></tr><tr><td><code>LinkedBlockingQueue</code></td><td><strong>链表实现，有界（默认 Integer.MAX_VALUE），阻塞</strong></td><td>✅</td></tr><tr><td><code>PriorityBlockingQueue</code></td><td><strong>优先级队列，阻塞</strong>，无界</td><td>✅</td></tr><tr><td><code>DelayQueue</code></td><td><strong>基于时间延迟出队，阻塞</strong></td><td>✅</td></tr><tr><td><code>SynchronousQueue</code></td><td><strong>无缓冲，生产者直接交给消费者，阻塞</strong></td><td>✅</td></tr><tr><td><code>LinkedTransferQueue</code></td><td><strong>支持 Transfer 操作</strong>，多生产者多消费者</td><td>✅</td></tr></tbody></table><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ul><li><code>offer()</code> / <code>poll()</code> / <code>peek()</code>：<strong>推荐使用</strong>，避免异常</li><li><code>add()</code> / <code>remove()</code> / <code>element()</code>：<strong>满/空时异常</strong>，不推荐</li><li><code>BlockingQueue</code>：<strong>支持阻塞</strong>，适用于 <strong>生产者-消费者</strong></li><li><code>ConcurrentLinkedQueue</code> / <code>ConcurrentLinkedDeque</code>：<strong>高并发无锁队列</strong>，适合高吞吐场景</li></ul>',23)]))}const k=d(n,[["render",c]]);export{h as __pageData,k as default};
