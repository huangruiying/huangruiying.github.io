import{_ as r,c as o,o as n,a1 as s}from"./chunks/framework.CPsxJxQM.js";const d="/assets/%E5%90%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5.EHvkN7af.png",p=JSON.parse('{"title":"算法理论部分简介","description":"","frontmatter":{},"headers":[],"relativePath":"算法整理/算法理论/index.md","filePath":"算法整理/算法理论/index.md"}'),l={name:"算法整理/算法理论/index.md"};function a(g,t,i,e,h,u){return n(),o("div",null,t[0]||(t[0]=[s('<h1 id="算法理论部分简介" tabindex="-1">算法理论部分简介 <a class="header-anchor" href="#算法理论部分简介" aria-label="Permalink to &quot;算法理论部分简介&quot;">​</a></h1><ul><li>1️⃣这里包括一些经典的算法思想、基本原理和证明方法 <ul><li>例如：Floyd判环算法、Brent判环算法、双指针技术等。</li></ul></li><li>2️⃣会针对一些问题，给出最佳实践 <ul><li>例如：排序算法不同数据量、数据特点，应该使用哪种算法组合。</li></ul></li></ul><h1 id="排序算法在不同数据量和数据情况下的最佳实践" tabindex="-1">排序算法在不同数据量和数据情况下的最佳实践 <a class="header-anchor" href="#排序算法在不同数据量和数据情况下的最佳实践" aria-label="Permalink to &quot;排序算法在不同数据量和数据情况下的最佳实践&quot;">​</a></h1><p>以下是不同数据规模、数据分布下的排序算法最佳实践，以及一个针对大规模数据的优化排序方案。</p><h2 id="基础-各排序算法最坏情况" tabindex="-1"><strong>基础:各排序算法最坏情况</strong> <a class="header-anchor" href="#基础-各排序算法最坏情况" aria-label="Permalink to &quot;**基础:各排序算法最坏情况**&quot;">​</a></h2><p><img src="'+d+'" alt="各排序算法最坏情况.png"></p><h2 id="理论-排序算法的最佳实践" tabindex="-1"><strong>理论: 排序算法的最佳实践</strong> <a class="header-anchor" href="#理论-排序算法的最佳实践" aria-label="Permalink to &quot;**理论: 排序算法的最佳实践**&quot;">​</a></h2><table tabindex="0"><thead><tr><th>数据规模</th><th>数据特点</th><th>最佳排序算法</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>小数据量</strong> <br> (N ≤ 1000)</td><td>近乎有序</td><td><strong>插入排序</strong> (O(N))</td><td>适用于基本有序的数据，交换次数少</td></tr><tr><td></td><td>大量重复值</td><td><strong>计数排序</strong> (O(N))</td><td>适用于数据范围较小的整数</td></tr><tr><td></td><td>无明显特征</td><td><strong>快速排序</strong> (O(N log N))</td><td>适用于大部分情况</td></tr><tr><td><strong>中等数据量</strong> <br> (1000 &lt; N ≤ 1,000,000)</td><td>近乎有序</td><td><strong>归并排序</strong> (O(N log N))</td><td>适用于链表排序，稳定性好</td></tr><tr><td></td><td>大量重复值</td><td><strong>三路快速排序</strong> (O(N log N))</td><td>适用于重复值多的情况</td></tr><tr><td></td><td>无明显特征</td><td><strong>堆排序</strong> (O(N log N))</td><td>不依赖额外空间，适用于数据流处理</td></tr><tr><td><strong>大数据量</strong> <br> (N &gt; 1,000,000)</td><td>磁盘存储</td><td><strong>外部归并排序</strong> (O(N log N))</td><td>适用于数据量超内存的情况</td></tr><tr><td></td><td>结构化数据</td><td><strong>桶排序 + 并行计算</strong></td><td>适用于数据分布均匀</td></tr><tr><td></td><td>高重复率</td><td><strong>基数排序</strong> (O(N))</td><td>适用于整数排序</td></tr></tbody></table><h2 id="实践-大规模数据排序优化" tabindex="-1"><strong>实践: 大规模数据排序优化</strong> <a class="header-anchor" href="#实践-大规模数据排序优化" aria-label="Permalink to &quot;**实践: 大规模数据排序优化**&quot;">​</a></h2><p>假设我们有 <strong>10亿</strong> 条 <strong>整数数据</strong> (N = 1,000,000,000)，且数据值范围在 <strong>0~10亿</strong> 之间，需要高效排序。</p><h3 id="_1️⃣-拆解数据特征" tabindex="-1"><strong>1️⃣ 拆解数据特征</strong> <a class="header-anchor" href="#_1️⃣-拆解数据特征" aria-label="Permalink to &quot;**1️⃣ 拆解数据特征**&quot;">​</a></h3><ul><li><strong>数据量大</strong> → 不能全量载入内存，需要<strong>分批处理</strong></li><li><strong>整数范围已知</strong> → 可以考虑<strong>桶排序</strong></li><li><strong>可能有重复值</strong> → 适合<strong>计数排序</strong></li><li><strong>数据流式输入</strong> → 需要<strong>堆排序</strong> 或 <strong>归并排序</strong></li></ul><h3 id="_2️⃣-采用混合排序策略" tabindex="-1"><strong>2️⃣ 采用混合排序策略</strong> <a class="header-anchor" href="#_2️⃣-采用混合排序策略" aria-label="Permalink to &quot;**2️⃣ 采用混合排序策略**&quot;">​</a></h3><h4 id="📌-方案" tabindex="-1"><strong>📌 方案</strong> <a class="header-anchor" href="#📌-方案" aria-label="Permalink to &quot;**📌 方案**&quot;">​</a></h4><ol><li><p><strong>桶划分</strong>（分而治之）</p><ul><li>根据数值范围，将数据分成 <strong>1000 个桶</strong>（每个桶负责 100 万个整数）</li><li>这样可以确保每个桶的大小相对均衡，避免单个桶过大</li></ul></li><li><p><strong>桶内排序</strong></p><ul><li><strong>若桶内数据量 &lt; 10 万</strong>，使用<strong>快速排序</strong></li><li><strong>若桶内数据高度重复</strong>，使用<strong>计数排序</strong></li><li><strong>若桶内数据接近有序</strong>，使用<strong>插入排序</strong></li><li><strong>若桶内数据不规则</strong>，使用<strong>归并排序</strong></li></ul></li><li><p><strong>归并排序</strong></p><ul><li>将 1000 个桶的排序结果，使用 <strong>最小堆 (k-way merge)</strong> 进行<strong>归并排序</strong></li><li>堆的大小设置为 1000，减少磁盘 IO</li></ul></li><li><p><strong>多线程优化</strong></p><ul><li><strong>每个桶的排序可以并行</strong>，利用 <strong>线程池</strong></li><li><strong>最终归并阶段使用多线程堆排序</strong>，提升吞吐量</li></ul></li></ol>',15)]))}const _=r(l,[["render",a]]);export{p as __pageData,_ as default};
